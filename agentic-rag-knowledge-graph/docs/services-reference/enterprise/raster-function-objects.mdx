---
title: "Raster function objects"
description: "Learn about the JSON representation of raster function objects."
slug: "raster-function-objects"
url: "/raster-function-objects"
---

## Overview

This topic discusses the JSON representation of raster function objects, as well as raster function template syntax and examples.

The image service includes multiple operations that support the renderingRule parameter. A rendering rule defines how the requested image will be rendered or processed. It consists of a raster function, associated arguments, output pixel type, and variable name. The raster function name identifies the processing or rendering to be performed, the associated arguments provide parameter name value pairs used by the processing, and the output pixel type defines the output image's pixel type. Among the raster function arguments, there is one or more arguments that take rasters as input. The variableName operation identifies the argument name that takes raster inputs.

The image service includes a few well-known raster functions that do not need to be preconfigured with the service. 

<Note>

ArcGIS supports numerous raster functions. Not all raster functions in ArcGIS are directly exposed as well-known functions, but they can be used in service-defined raster function templates. For more information, see [Perform server-side processing with raster functions](https://enterprise.arcgis.com/en/server/latest/publish-services/windows/server-side-raster-functions.htm) and [What are the functions used by a raster or mosaic dataset](https://pro.arcgis.com/en/pro-app/latest/help/analysis/raster-functions/list-of-raster-functions.htm).

</Note>

These well-known functions include the following, organized alphabetically:

#### A

<CardGroup perRow={3}>
  <Card href="#argstatistics" mini>
    <CardHeader>
      <h2>ArgStatistics</h2>
    </CardHeader>
  </Card>
  <Card href="#arithmetic" mini>
    <CardHeader>
      <h2>Arithmetic</h2>
    </CardHeader>
  </Card>
  <Card href="#aspect" mini>
    <CardHeader>
      <h2>Aspect</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### B

<CardGroup perRow={3}>
  <Card href="#bandarithmetic" mini>
    <CardHeader>
      <h2>BandArithmetic</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### C

<CardGroup perRow={3}>
  <Card href="#ccdc" mini>
    <CardHeader>
      <h2>CCDC</h2>
    </CardHeader>
  </Card>
  <Card href="#classify" mini>
    <CardHeader>
      <h2>Classify</h2>
    </CardHeader>
  </Card>
  <Card href="#clip" mini>
    <CardHeader>
      <h2>Clip</h2>
    </CardHeader>
  </Card>
  <Card href="#colormap" mini>
    <CardHeader>
      <h2>Colormap</h2>
    </CardHeader>
  </Card>
  <Card href="#colormaptorgb" mini>
    <CardHeader>
      <h2>ColormapToRGB</h2>
    </CardHeader>
  </Card>
  <Card href="#colorspaceconversion" mini>
    <CardHeader>
      <h2>ColorspaceConversion</h2>
    </CardHeader>
  </Card>
  <Card href="#complex" mini>
    <CardHeader>
      <h2>Complex</h2>
    </CardHeader>
  </Card>
  <Card href="#compositeband" mini>
    <CardHeader>
      <h2>CompositeBand</h2>
    </CardHeader>
  </Card>
  <Card href="#computechange" mini>
    <CardHeader>
      <h2>ComputeChange</h2>
    </CardHeader>
  </Card>
  <Card href="#contrastbrightness" mini>
    <CardHeader>
      <h2>ContrastBrightness</h2>
    </CardHeader>
  </Card>
  <Card href="#convolution" mini>
    <CardHeader>
      <h2>Convolution</h2>
    </CardHeader>
  </Card>
  <Card href="#createcolorcomposite" mini>
    <CardHeader>
      <h2>CreateColorComposite</h2>
    </CardHeader>
  </Card>
  <Card href="#curvature" mini>
    <CardHeader>
      <h2>Curvature</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### D

<CardGroup perRow={3}>
  <Card href="#detectchange" mini>
    <CardHeader>
      <h2>DetectChange</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### E

<CardGroup perRow={3}>
  <Card href="#elevationvoidfill" mini>
    <CardHeader>
      <h2>ElevationVoidFill</h2>
    </CardHeader>
  </Card>
  <Card href="#extractband" mini>
    <CardHeader>
      <h2>ExtractBand</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### G

<CardGroup perRow={3}>
  <Card href="#geometric" mini>
    <CardHeader>
      <h2>Geometric</h2>
    </CardHeader>
  </Card>
  <Card href="#grayscale" mini>
    <CardHeader>
      <h2>Greyscale</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### H

<CardGroup perRow={3}>
  <Card href="#hillshade" mini>
    <CardHeader>
      <h2>Hillshade</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### I

<CardGroup perRow={3}>
  <Card href="#identity" mini>
    <CardHeader>
      <h2>Identity</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### L

<CardGroup perRow={3}>
  <Card href="#local" mini>
    <CardHeader>
      <h2>Local</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### M

<CardGroup perRow={3}>
  <Card href="#mask" mini>
    <CardHeader>
      <h2>Mask</h2>
    </CardHeader>
  </Card>
  <Card href="#mlclassify" mini>
    <CardHeader>
      <h2>MLClassify</h2>
    </CardHeader>
  </Card>
  <Card href="#multidimensionalraster" mini>
    <CardHeader>
      <h2>MultidimensionalRaster</h2>
    </CardHeader>
  </Card>
    <Card href="#multidimensionalfilter" mini>
    <CardHeader>
      <h2>MultidimensionalFilter</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### N

<CardGroup perRow={3}>
  <Card href="#ndvi" mini>
    <CardHeader>
      <h2>NDVI</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### P

<CardGroup perRow={3}>
  <Card href="#pansharpening" mini>
    <CardHeader>
      <h2>Pansharpening</h2>
    </CardHeader>
  </Card>
  <Card href="#processrastercollection" mini>
    <CardHeader>
      <h2>ProcessRasterCollection</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### R

<CardGroup perRow={3}>
  <Card href="#rastercalculator" mini>
    <CardHeader>
      <h2>RasterCalculator</h2>
    </CardHeader>
  </Card>
  <Card href="#recast" mini>
    <CardHeader>
      <h2>Recast</h2>
    </CardHeader>
  </Card>
  <Card href="#remap" mini>
    <CardHeader>
      <h2>Remap</h2>
    </CardHeader>
  </Card>
  <Card href="#resample" mini>
    <CardHeader>
      <h2>Resample</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### S

<CardGroup perRow={3}>
  <Card href="#segmentmeanshift" mini>
    <CardHeader>
      <h2>SegmentMeanShift</h2>
    </CardHeader>
  </Card>
  <Card href="#shadedrelief" mini>
    <CardHeader>
      <h2>ShadedRelief</h2>
    </CardHeader>
  </Card>
  <Card href="#slope" mini>
    <CardHeader>
      <h2>Slope</h2>
    </CardHeader>
  </Card>
  <Card href="#speckle" mini>
    <CardHeader>
      <h2>Speckle</h2>
    </CardHeader>
  </Card>
  <Card href="#spectralconversion" mini>
    <CardHeader>
      <h2>SpectralConversion</h2>
    </CardHeader>
  </Card>
  <Card href="#spectralunmixing" mini>
    <CardHeader>
      <h2>SpectralUnmixing</h2>
    </CardHeader>
  </Card>
  <Card href="#statistics" mini>
    <CardHeader>
      <h2>Statistics</h2>
    </CardHeader>
  </Card>
  <Card href="#statisticshistogram" mini>
    <CardHeader>
      <h2>StatisticsHistogram</h2>
    </CardHeader>
  </Card>
  <Card href="#stretch" mini>
    <CardHeader>
      <h2>Stretch</h2>
    </CardHeader>
  </Card>
  <Card href="#surfaceparamfunction" mini>
    <CardHeader>
      <h2>SurfaceParamFunction</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### T

<CardGroup perRow={3}>
  <Card href="#tasseledcap" mini>
    <CardHeader>
      <h2>TasseledCap</h2>
    </CardHeader>
  </Card>
  <Card href="#threshold" mini>
    <CardHeader>
      <h2>Threshold</h2>
    </CardHeader>
  </Card>
  <Card href="#transposebits" mini>
    <CardHeader>
      <h2>TransposeBits</h2>
    </CardHeader>
  </Card>
  <Card href="#trend" mini>
    <CardHeader>
      <h2>Trend</h2>
    </CardHeader>
  </Card>
  <Card href="#trendanalysis" mini>
    <CardHeader>
      <h2>TrendAnalysis</h2>
    </CardHeader>
  </Card>
  <Card href="#trendtorgb" mini>
    <CardHeader>
      <h2>TrendToRGB</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### U

<CardGroup perRow={3}>
  <Card href="#unitconversion" mini>
    <CardHeader>
      <h2>UnitConversion</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### V

<CardGroup perRow={3}>
  <Card href="#vectorfield" mini>
    <CardHeader>
      <h2>Vectorfield</h2>
    </CardHeader>
  </Card>
  <Card href="#vectorfieldrenderer" mini>
    <CardHeader>
      <h2>VectorFieldRenderer</h2>
    </CardHeader>
  </Card>
</CardGroup>

#### W

<CardGroup perRow={3}>
  <Card href="#weightedoverlay" mini>
    <CardHeader>
      <h2>WeightedOverlay</h2>
    </CardHeader>
  </Card>
  <Card href="#weightedsum" mini>
    <CardHeader>
      <h2>WeightedSum</h2>
    </CardHeader>
  </Card>
</CardGroup>

### Use a raster function template defined by the service

A raster function template defines a processing chain composed of one or more raster functions, including customized raster functions that are extended based on ArcObjects. Information about these raster function templates is available through the `RasterFunctionInfos` property in the [Image Service](/image-service) topic. A client can omit `rasterFunctionArguments` and use the default configuration in the raster function template, or overwrite them by specifying argument parameters.

The name of the raster function template is displayed in the image service root resource. Function arguments are optional; argument names and default values are created by the author of the raster function template and are not known through REST. A client can provide the name of the raster function template only to the `RasterFunction` property or, optionally, provide arguments to overwrite the default values.

Service-defined raster function templates can group rasters using a designated attribute and resolve rasters using a tag. For example, a fish habitat suitability model may need multiple rasters from different variables, such as water temperature, salinity, and so on. The service publisher can define a raster function template that groups rasters by an attribute, for example, an attribute representing a particular slice in time and depth. Then it can resolve these rasters in a group using a tagged attribute, for example `tag` or `variableName`. The client can get this information from `rasterFunctionInfos`; the grouping and tagging are done on the server side, so the client can simply invoke the template.

For more information about authoring server-side raster function templates, see [Server-side processing with raster functions](https://enterprise.arcgis.com/en/server/latest/publish-services/windows/server-side-raster-functions.htm).

```markdown label=Syntax
{
  "rasterFunction": "rasterFunctionTemplateName",
  "rasterFunctionArguments": {
    "ArgumentName1": <>, //overwrite default value of ArgumentName1, type and default value are defined by the author of the template
    "ArgumentName2": <>, //overwrite default value of ArgumentName2, type and default value are defined by the author of the template
    ...
  },
  "variableName": "<>" //variableName can be other than "Raster", as defined by the author of the template
}
```

<Box>

The following service has raster function templates defined:

```markdown
https://sampleserver6.arcgisonline.com/arcgis/rest/services/CharlotteLAS/ImageServer?f=pjson
```

This resource returns the following information for the supported raster function templates:

```markdown
"rasterFunctionInfos": [
  {
    "name": "None",
    "description": "A No-Op Function.",
    "help": ""
  },
  {
    "name": "RFTAspectColor",
    "description": "A raster function template.",
    "help": "This raster function template contains the following processing: aspect, remap, colormap and colormap to RGB functions. The remap function remaps divide 0 to 90 evenly to 8 directions, (N,NE,E,SE,S,SW,W,NW). The colormap function used the following color map for the 8 categories: [[0 176 176 176], [1 255 0 0],[2 255 166 0],[3 255 255 0],[4 0 255 0],[5 0 255 255],[6 0 166 255],[7 0 0 255],[8 255 0 255]]. To overwrite the default setting, use InputRanges (double array), NoDataRanges (double array), and OutputValues (int array) for remapping, and use Colormap to change colors."
  },
  {
    "name": "RFTShadedReliefElevationColorRamp",
    "description": "A raster function template.",
    "help": "This raster function template uses a shaded relief function. The default values of ZFactor is 1, Altitude is 45, and Azimuth is 315. An elevation colorramp is used."
  }
]
```

A client can use the use the supported raster functions with their default arguments, without additional properties included:

```markdown
https://sampleserver6.arcgisonline.com/arcgis/rest/services/CharlotteLAS/ImageServer/exportImage?bbox=1440000.0,535000.0,1455000.0,550000.0&bboxSR=&size=400,400&imageSR=&format=jpgpng&pixelType=UNKNOWN&noData=&interpolation=RSP_BilinearInterpolation&mosaicRule=&renderingRule={"rasterFunction": "RFTShadedReliefElevationColorRamp"}&f=image
```
A client can also use the supported raster functions with optional properties:

```markdown
https://sampleserver6.arcgisonline.com/arcgis/rest/services/CharlotteLAS/ImageServer/exportImage?bbox=1440000.0,535000.0,1455000.0,550000.0&bboxSR=&size=400,400&imageSR=&format=jpgpng&pixelType=UNKNOWN&noData=&interpolation=RSP_BilinearInterpolation&mosaicRule=&renderingRule={"rasterFunction": "RFTShadedReliefElevationColorRamp","rasterFunctionArguments":{"ZFactor":10},"variableName":"Raster"}&f=image
```
</Box>

#### Turn off a default raster function template

By default, the [Export Image](/export-image) operation applies the first raster function template in `rasterFunctionInfos`. You can change the rendering rule using the `renderingRule` parameter, or apply no additional processing by setting `rasterFunction` as `None`. If the first raster function template is None, it means, by default, no raster function template is used. The image service can use a default renderer if needed.

The following service (Toronto) has a `Stretch` function template applied by default:
* [Toronto stretch example](http://sampleserver6.arcgisonline.com/arcgis/rest/services/Toronto/ImageServer/exportImage?bbox=-8844874.0651,5401062.402699997,-8828990.0651,5420947.402699997&bboxSR=&size=400,400&imageSR=&format=jpgpng&mosaicRule=&f=image)

The Toronto service can have disable additional processing by specifying `None` as the raster function:
* [Toronto none example](https://sampleserver6.arcgisonline.com/arcgis/rest/services/Toronto/ImageServer/exportImage?bbox=-8844874.0651,5401062.402699997,-8828990.0651,5420947.402699997&bboxSR=&size=400,400&imageSR=&format=jpgpng&mosaicRule=&renderingRule=%7B%22rasterFunction%22:%22None%22%7D&f=image)

When a single-band image service has a raster attribute table and RGB colors are available in the attribute table, Export Image automatically uses it to render an image service by default:
* [NLCD RGB example](http://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=-2364615.0,256035.0,2266845.0,3180435.0&bboxSR=&size=&imageSR=&time=&format=jpgpng&pixelType=UNKNOWN&noData=&interpolation=%20RSP_BilinearInterpolation&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image)

This behavior can be turned off in the same way by specifying `None` as the raster function:
* [NLCD default example](http://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=-2364615.0,256035.0,2266845.0,3180435.0&bboxSR=&size=&imageSR=&time=&format=jpgpng&pixelType=UNKNOWN&noData=&interpolation=%20RSP_BilinearInterpolation&compressionQuality=&bandIds=&mosaicRule=&renderingRule=%7B%22rasterFunction%22:%22None%22%7D&f=image)

### Define a raster function template on the client side

A client can define a raster function template in the following ways: 

* by assigning a well-known raster function object as the value of a raster function argument. The argument must take a raster as input, for example specifying either `Raster` or `DEM`.
* by chaining multiple well-known raster functions and specifying output pixel types; this does not apply to service-defined raster function templates.

In addition to well-known functions, service-defined raster function templates can also be used in client-defined raster function templates.

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "<rasterFunctionName>",
    "rasterFunctionArguments": {
      "argument1": <value1>,
      "argument2": <value2>,     
      "argumentn": <valuen>,
      "Raster": {  //this is the argument that takes raster inputs, e.g. DEM for the Hillshade function
        "rasterFunction": "<rasterFunctionName>",
        "rasterFunctionArguments": {
          "argument1": <value1>,
          "argument2": <value2>,
          "argumentn": <valuen>
        },
        "outputPixelType": "<outputPixelType>",
        "variableName": "<variableName>" //the inner function's variableName
      }
    },
    "outputPixelType": "<outputPixelType>"      
  }
  ```
</Tab>

<Tab>

This example demonstrates red and blue color mapping for a temperature image service (above or below 0° C).

  ```markdown
  {
    "rasterFunction": "Colormap",
    "rasterFunctionArguments": {
      "Colormap": [
        [0, 255, 0, 0],
        [2, 0, 0, 255]
      ],
      "Raster": {
        "rasterFunction": "Remap",
        "rasterFunctionArguments": {
          "InputRanges": [-50.0,0,0,50],
          "OutputValues": [0,2],
          "Raster": "$$"
        },
        "outputPixelType": "U8"
      }     
    },
    "outputPixelType": "U8"
  }
  ```
</Tab>

</Tabs>

### Use rasters in rendering rules

The `variableName` value of a rendering rule designates which argument has a type of raster or rasters. It's optional for the following cases:

* Well-known functions—The image service can find them based on the raster function name.
* Service-defined raster function templates that use `Raster` or `Rasters` as the `variableName`.

Among the raster function arguments, there's one or more arguments that take a raster or an array of rasters as input, for example, the `Raster` argument for the Remap function and the `DEM` argument for the `Hillshade` function. A raster value can be the image service (`$$`) default, an image in the image service (`$oid`), or a result from another function (a rendering rule object). The argument name value pair can be optional in the following cases, and when not provided, the default is the image service (`"Raster":"$$"`):

* Well-known functions—Functions that use `Raster` or `DEM` as the argument name.
* Service-defined raster function templates if the argument name is `Raster`; otherwise, it must be provided.

You can reference an image in an image service or the result from another function. When using an individual raster in an image service as input, the `Raster` argument must be part of `rasterFunctionArguments`. The value of this argument is a dollar-objectID notation of the raster, for example, `"Raster":"$1"`. When using the image service as input, you can also use `$$` to represent the image service as part of rasterFunctionArguments (for example, `"Raster":"$$"`).

<Tabs>

<TabNav>
  <TabTitle>Stretch the first raster</TabTitle>
  <TabTitle>Stretch the service</TabTitle>
</TabNav>

<Tab>

This example demonstrates stretching the first raster.

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 3,
      "NumberOfStandardDeviations": 2.5,
      "Statistics": [
        [0, 255, 56.7, 54.8],
        [0, 255, 97.5, 94.5],
        [0, 255, 87.5, 87.3]
      ],
      "Gamma": [1.25, 1.25, 1.25],
    "Raster": "$1"
    },
    "outputPixelType": "U8"
  }
  ```
</Tab>

<Tab>

This example demonstrates stretching the service.

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 3,
      "NumberOfStandardDeviations": 2.5,
      "Statistics": [
        [0, 255, 56.7, 54.8],
        [0, 255, 97.5, 94.5],
        [0, 255, 87.5, 87.3]
      ],
      "Gamma": [1.25, 1.25, 1.25],
    "Raster": "$$"
    },
  "outputPixelType": "U8"
  }
  ```
</Tab>

</Tabs>

### Multidimensional raster inputs

All raster functions that support multiple multidimensional raster inputs also support the following two multidimensional arguments:

* `MatchVariable`—When this argument is set to `true`, the raster function will only proceed if the variables in the two or more input multidimensional rasters have the same name. This is the default. When it is set to `false`, the input multidimensional rasters can have variables with different names.
* `UnionDimension`—When this argument is set to `true`, the raster function will only proceed if the dimensions in the two or more input multidimensional rasters have the same name. This is the default. When it is set to `false`, the dimensions do not have to have matching names, and the result will be the union of the dimensions. For example, if you add two multidimensional rasters that both have an ocean temperature variable named "temp", but one measure along dimension Time and one measure along dimension Depth, the result will be a multidimensional raster with both Time and Depth dimensions in which the temperature variable has been added together for each combination of dimensions.

### Well-known functions

#### ArgStatistics

The `ArgStatistics` function produces an output with a pixel value that represents a statistical metric from all bands of input rasters. The statistics can be the band index of the maximum, minimum, or median value, or the duration (number of bands) between a minimum and maximum value. For more information, see [ArgStatistics function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/argstatistics-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "ArgStatistics",
    "rasterFunctionArguments": {
      "ArgStatisticsType": <ArgStatisticsType>,  //int 0=maximum, 1= minimum, 2=median, 3=duration
      "MinValue": <MinValue>,  //double, required if the type is duration
      "MaxValue": <MaxValue>,  //double, required if the type is duration
      "UndefinedClass": <UndefinedClass>,  //int, required if the type is maximum or minimum
      "Rasters": [  //array of rasters.
        <raster1>,
        <raster2>,
        <raster3>
      ], 
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

This example demonstrates how to calculate the duration between 0.15 to 1 (the number of continuous bands that meet the condition):

  ```markdown
  {
    "rasterFunction": "ArgStatistics",
    "rasterFunctionArguments": {
      "ArgStatisticsType": 3,
      "MinValue": 0.15,
      "MaxValue": 1,
      "UndefinedClass": 100,
      "Raster": "$$"
    }  
  }
  ```
</Tab>

</Tabs>

#### Arithmetic

The `Arithmetic` function performs an arithmetic operation between two rasters or a raster and a scalar, and vice versa. For more information, see [Arithmetic function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/arithmetic-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Arithmetic",
    "rasterFunctionArguments": {
      "Raster": <Raster>,  //raster, or scalars(space delimited string, or array of double) 
      "Raster2": <Raster2>,  //raster, or scalars(space delimited string, or array of double)
      "Operation": <Operation>,  //int 1=esriRasterPlus, 2=esriRasterMinus, 3=esriRasterMultiply, 4=esriRasterDivide, 5=esriRasterPower, 6=esriRasterMode
      "ExtentType": <ExtentType>,  //int; optional; default 0; 0=esriExtentFirstOf, 1=esriExtentIntersectionOf, 2=esriExtentUnionOf, 3=esriExtentLastOf 
      "CellsizeType": <CellsizeType>,  //int; optional; default 0; 0=esriCellsizeFirstOf, 1=esriCellsizeMinOf, 2=esriCellsizeMaxOf, 3=esriCellsizeMeanOf, 4=esriCellsizeLastOf
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",  //optional
  }
  ```
</Tab>

<Tab>

This example demonstrates the `esriRasterMinus` (`W`) operation:

  ```markdown
  {
    "rasterFunction": "Arithmetic",
    "rasterFunctionArguments": {
      "Raster" : "$$",
      "Raster2": "100",
      "Operation" : 2
    }  
  }
  ```
</Tab>

</Tabs>

#### Aspect

The `Aspect` function identifies the downslope direction of the maximum rate of change in value from each cell to its neighbors. The values of the output raster will be the compass direction of the aspect. For more information, see [Aspect function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/aspect-function.htm) and [How Aspect works](https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-analyst-toolbox/how-aspect-works.htm).

The `Aspect` function takes no arguments.

```markdown
{
  "rasterFunction": "Aspect"
}
```

#### BandArithmetic

The `BandArithmetic` function performs an arithmetic operation on the bands of a raster dataset. For more information, see [Band Arithmetic function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/bandarithmetic.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```other
  {
    "rasterFunction": "BandArithmetic",
    "rasterFunctionArguments": {
      "Method": <Method>,  //int (0 = UserDefined, 1 = NDVI, 2 = SAVI, 3 = TSAVI, 4 = MSAVI, 5 = GEMI, 6 = PVI, 7 = GVITM, 8 = Sultan, 9 = VARI)
      "BandIndexes": "<BandIndexes>",  //string e.g. (B3 - B1 / B3 + B1)
      "Raster": <raster>  //optional, default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
  The equations and corresponding band indexes are listed below for each method. In all equations, NIR equals pixel values from the near-infrared band, and Red equals pixel values from the red band.

  <StyledTable headers={"Method,Details"}>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `0`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        User defined

        * Use a single-line algebraic formula to create a single-band output. The supported operators are `-`, `+`, `/`, `*`, and unary `-`.
        * To identify the bands, prepend the band number with a `B` or `b`. For example: "BandIndexes":"(B1 + B2) / (B3 * B5)"

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `1`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Normalized Difference Vegetation Index (NDVI)

        ```other
        ((NIR - Red)/(NIR + Red))
        ```
        * BandIndexes: "NIR Red", e.g., "4 3"
        * Reference: Pinty, B. and Verstraete, M. M. 1992, "GEMI: a non-linear index to monitor global vegetation from satellites," Plant Ecology, Vol. 101, 15-20.

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `2`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Soil-Adjusted Vegetation Index (SAVI)

        ```other
        ((NIR - Red) / (NIR + Red + L)) x (1 + L)
        ```
        * where L represents amount of green vegetative cover, e.g., 0.5
        * "BandIndexes": "NIR Red L", for example, "4 3 0.33"
        * Reference: Huete, A. R., 1988, "A soil-adjusted vegetation index (SAVI)," Remote Sensing of Environment, Vol 25, 295-309.

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `3`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Transformed Soil Adjusted Vegetation Index (TSAVI)

        ```other
        (s(NIR-s*Red-a))/(a*NIR+Red-a*s+X*(1+s^2))
        ```
        * Where:
          * a = the soil line intercept
          * s = the soil line slope
          * X = an adjustment factor that is set to minimize soil noise
        * "BandIndexes": "NIR Red s a X", e.g., "4 3 0.33 0.50 1.50"
        * Reference: Baret, F. and G. Guyot, 1991, "Potentials and limits of vegetation indices for LAI and APAR assessment," Remote Sensing of Environment, Vol. 35, 161-173.

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `4`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Modified Soil Adjusted Vegetation Index (MSAVI2)

        ```other
        (1/2)*(2(NIR+1)-sqrt((2*NIR+1)^2-8(NIR-Red)))
        ```
        * BandIndexes: "NIR Red", e.g., "4 3"
        * Reference: Qi, J. et al., 1994, "A modified soil vegetation adjusted index, " Remote Sensing of Environment, Vol. 48, No. 2, 119-126.

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `5`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Global Environmental Monitoring Index (GEMI)

        ```other
         eta*(1-0.25*eta)-((Red-0.125)/(1-Red))
        ```

        where eta = 

        ```other
         (2*(NIR^2-Red^2)+1.5*NIR+0.5*Red)/(NIR+Red+0.5)
        ```

        * BandIndexes":"NIR Red", e.g., "4 3"
        * Reference: Pinty, B. and Verstraete, M. M. 1992, "GEMI: a non-linear index to monitor global vegetation from satellites," Plant Ecology, Vol. 101, 15-20,

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `6`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Perpendicular Vegetation Index (PVI)

        ```other
        (NIR-a*Red-b)/(sqrt(1+a^2))
        ```
        * where a = slope of the soil line, b = gradient of the soil line
        * BandIndexes: "NIR Red a b", e.g., "4 3 0.3 0.5"

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `7`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Green Vegetation Index - Landsat TM (GVITM)

        ```other
        -0.2848*Band1-0.2435*Band2-0.5436*Band3+0.7243*Band4+0.0840*Band5-1.1800*Band7
        ```
        * "BandIndexes":"Band1 Band2 Band3 Band4 Band5 Band7", e.g., "1 2 3 4 5 6"
        * Reference: Todd, S. W., R. M. Hoffer, and D. G. Milchunas, 1998, "Biomass estimation on grazed and ungrazed rangelands using spectral indices," International Journal of Remote Sensing, Vol. 19, No. 3, 427-438.

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `8`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Sultan's Formula (transform to 3 band 8 bit image)

        Band 1:

        ```markdown
        (Band5 / Band6) x 100
        ```

         Band 2:

        ```markdown
        (Band5 / Band1) x 100
        ```

        Band 3:

        ```markdown
        (Band3 / Band4) x (Band5 / Band4) x 100
        ```

        * "BandIndexes":"Band1 Band2 Band3 Band4 Band5 Band6", e.g., "1 2 3 4 5 6"

      </StyledTableCell>
    </StyledTableRow>
    <StyledTableRow>
      <StyledTableCell cellStyle="markdown">

        `9`

      </StyledTableCell>
      <StyledTableCell cellStyle="markdown">

        Visible Atmospherically Resistant Index (VARI)

        ```markdown
         (Green - Red)/(Green + Red - Blue)
        ```
        * BandIndexes: "Red Green Blue", e.g., "3 2 1"
        * Reference: Anatoly A. Gitelson, Yoram J. Kaufman, Robert Stark, and Don Rundquist, 2002, "Novel algorithms for remote estimation of vegetation fraction," Remote Sensing of Environment, Vol. 80, 76-87.

      </StyledTableCell>
    </StyledTableRow>
  </StyledTable>

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "BandArithmetic",
    "rasterFunctionArguments": {
      "Method": 0,
      "BandIndexes": "(B3 - B1 / B3 + B1)",
      "Raster": <raster>  //optional, default is the image service 
    },
    "variableName": "Raster"
  }
  ```
</Tab>

</Tabs>

#### CCDC

Introduced at 10.8.1, the `CCDC` function evaluates changes in pixel values over time using the Continuous Change Detection and Classification (CCDC) algorithm and generates a multidimensional raster containing the model results. For more information, see [CCDC Analysis function](https://doc.arcgis.com/en/arcgis-online/analyze/ccdc-analysis-function.htm).

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "CCDC",
    "rasterFunctionArguments": {
      "Raster": <Raster>, //the input raster
      "BandIDs":  [
        <Band1>,
        <band2>,
        …
      ],//int, optional
      "TmaskBandIDs": [
        <Band2>,
        <Band4>,
        …
      ], //int, optional
      "ChiSquareProb": <ChiSquareProb>, //int, optional
      "MinNumberAnomaly": <MinNumberAnomaly>, //int, optional
      "UpdatingFrequency": <UpdatingFrequency> //int, optional
    }
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": CCDC",
    "rasterFunctionArguments": {
      "Raster": "$$",
      "BandIDs": [
        1,
        2
      ]
    }
  }
  ```
</Tab>

</Tabs>

#### Classify

The `Classify` function classifies a segmented raster to a categorical raster. For more information, see [Classify function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/classify-function.htm).

<Note>

ArcGIS Server must be licensed as ArcGIS Server Advanced or ArcGIS Image Server to use this resource. For earlier versions, the hosting ArcGIS Server installation must have an ArcGIS Spatial Analyst extension license.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Classify",
    "rasterFunctionArguments": {
      "ClassifierDefinition": <Definition_json>, //a json object that defines the classifier parameters.    
      "Raster": <Raster>,  //the input raster, usually this is the service
      "Raster2": <Raster2>,  //optional. additional input raster which may contain the segment information. If provided, pixels in each segment will get same class assignments.
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

This example demonstrates how to classify a segmented image using the maximum likelihood classifier:

  ```markdown
  {
    "rasterFunction": "Classify",
    "rasterFunctionArguments": {
      "ClassifierDefinition": {  
        "EsriClassifierDefinitionFile": 0,
        "FileVersion": 1, 
        "NumberDefinitions": 1, 
        "Definitions": [
          {
            "Classifier": "MaximumLikelihood",
            "NumberClasses": 2,  
            "RasterIsSegmented": false,  
            "NumberBands": 3,
            "Classes": [ 
              {
                "ClassValue": 1,
                "ClassName": "Vegetation",
                "Red": 230,
                "Green": 0,
                "Blue": 0, 
                "Count": 546, 
                "Means": [
                  244.9359,
                  14.88278,
                  15.21978
                ],
                "Covariances": [
                  [
                    10.26146,
                    0.1390063,
                    0.1074951
                  ],
                  [
                    0.1390063,
                    10.31593,
                    1.207584E-04
                  ],
                  [
                    0.1074951,
                    1.207584E-04,
                    10.19345
                  ]
                ]
              },
              {
                "ClassValue": 2,
                "ClassName": "Water",
                "Red": 0,
                "Green": 77,
                "Blue": 168,
                "Count": 716,
                "Means": [
                  15.05587,
                  15.01257,
                  244.9567
                ],
                "Covariances": [
                  [
                    10.18124,
                    0.1152196,
                    0.2789551
                  ],
                  [
                    0.1152196,
                    10.02638,
                    -0.3583943
                  ],
                  [
                    0.2789551,
                    -0.3583943,
                    10.11684
                  ]
                ]
              }
            ]
          }
        ]
      }
    }  
  }
  ```
</Tab>

</Tabs>

#### Clip

The `Clip` function clips a raster using a rectangular shape according to the extents defined, or clips a raster to the shape of an input polygon feature class. The shape defining the clip can include the extent of the raster or an area within the raster. For more information, see [Clip function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/clip-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Clip",
    "rasterFunctionArguments": {
      "ClippingGeometry": <geometry>,  //a polygon or envelope
      "ClippingType": <clippingType>,  //int (1= clippingOutside, 2=clippingInside), use 1 to keep image inside of the geometry
      "Raster": <raster>,  //optional, default is the image service 
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Clip",
    "rasterFunctionArguments": {
      "ClippingGeometry": {
        "rings": [
          [
            [
              10,
              10
            ],
            [
              9,
              11
            ],
            [
              10,
              12
            ],
            [
              11,
              11
            ],
            [
              12,
              10
            ],
            [
              10,
              10
            ]
          ]
        ],
        "spatialReference": {
          "wkid": 4326
        }
      },
      "extent": {
        "xmin": 10,
        "ymin": 10,
        "xmax": 12,
        "ymax": 12,
        "spatialReference": {
          "wkid": 4326
        }
      },
      "ClippingType": 1
    },
    "variableName": "Raster"
  }
  ```
</Tab>

</Tabs>

#### Colormap

The `Colormap` function transforms the pixel values to display the raster data as a red, green, blue (RGB) color image, based on specific colors in a color map or a color range defined in a color ramp. For more information, see [Colormap function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/colormap.htm). You can display raster data using a predefined `ColorrampName` or a customized `Colorramp` object. Several ArcGIS predefined color ramps are provided.

![Color ramp](./images/colorramp.png "Color ramp")

Predefined color ramp graphics and their corresponding names can be viewed from the layer's properties window on the **Symbology** tab. The particular color ramp or scheme name is specified in the `ColorrampName` argument object. For more information about color ramp objects, see [Color ramp objects](/color-ramp-objects).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
  <TabTitle>Example 3</TabTitle>
  <TabTitle>Example 4</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Colormap",
    "rasterFunctionArguments": {
      "ColormapName": "<Random | NDVI | NDVI2 | NDVI3 | Elevation | Gray | Hillshade>",
      "Colormap": [
        [<value1>, <red1>, <green1>, <blue1>], //[int, int, int, int]
        [<value2>, <red2>, <green2>, <blue2>]
      ],
      "ColorrampName": "<Black To White | Yellow To Red | Slope | more…>",
      "Colorramp": {ColorRamp_json}comment //a json object that defines a range of colors,
      "Raster": <raster>//optional, default is the image service 	
    },
    "outputPixelType": "<outputPixelType>",//optional
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Colormap",
    "rasterFunctionArguments": {
      "ColormapName": "Random"
    },
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Colormap",
    "rasterFunctionArguments": {
      "Colormap": [
        [1,255,0,0],
        [2,0,255,0],
        [3,125,25,255]
      ]
    },
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Colormap", 
    "rasterFunctionArguments": {
      "ColorrampName": "Blue Bright"
    },
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Colormap",
    "rasterFunctionArguments": {
      "colorramp": {
        "type": "multipart",
        "colorRamps": [
          {
            "type": "algorithmic",
            "fromColor": [
              255,
              0,
              0,
              255
            ],
            "toColor": [
              0,
              255,
              0,
              255
            ],
            "algorithm": "esriHSVAlgorithm"
          },
          {
            "type": "algorithmic",
            "fromColor": [
              155,
              34,
              78,
              255
            ],
            "toColor": [
              255,
              0,
              0,
              255
            ],
            "algorithm": "esriCIELabAlgorithm"
          }
        ]
      }
    }
  }
  ```
</Tab>

</Tabs>

#### ColormapToRGB

The `ColormapToRGB` function works with single band image service that has an internal color map. It converts the image to a three-band 8-bit RGB raster. This function takes no arguments except an input raster. For a qualified image service, there are two situations when the ColormapToRGB function is automatically applied: The `colormapToRGB` property of the image service is set to `true`, or the client requests to export the image to JPG or PNG format. For more information, see [Colormap To RGB function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/colormap-to-rgb.htm).

The `UnmappedAsRandomColor` will assign a random RGB color to the pixel when set to `true` and `colormap` doesn’t specify how a raster pixel value.

```markdown label=Syntax
{
  "rasterFunction": "ColormapToRGB",
  "rasterFunctionArguments": {
    "Raster": <raster>,  //optional, default is the image service
    "UnmappedAsRandomColor": <true|false>, //the default is false
  }
}
```

#### ColorspaceConversion

The `ColorspaceConversion` function converts the color model of a three-band unsigned 8-bit image from hue, saturation, and value (HSV) to red, green, and blue (RGB) or vice versa. The `ExtractBand` function or Stretch function are sometimes used for converting the imagery into valid input for the `ColorspaceConversion` function. For more information, see [Color Model Conversion function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/colorspaceconversion.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "ColorspaceConversion",
    "rasterFunctionArguments": {
      "ConversionType": <int>, //0: convert color model from RGB to HSV; 1: convert color model from HSV to RGB
      "Raster": "$$" //optional, default is the image service
    }
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "ColorspaceConversion",
    "rasterFunctionArguments": {
      "ConversionType": 0,
      "raster": "$$"
    }
  }
  ```
</Tab>

</Tabs>

#### Complex

The `Complex` function is used when the input raster has a complex pixel type. It computes magnitude from the complex value to convert the pixel type to floating point for each pixel. It takes no arguments except an optional input raster. For more information, see [Complex function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/complex.htm).

```markdown
{
  "rasterFunction": "Complex",
  "rasterFunctionArguments": {
    "Raster": <raster> //optional, default is the image service
  }
}
```

#### CompositeBand

The `CompositeBand` function combines multiple images to form a multiband image. For more information, see [Composite Bands function](https://desktop.arcgis.com/en/arcmap/latest/tools/data-management-toolbox/composite-bands.htm).

```markdown
{
  "rasterFunction": "CompositeBand",
  "rasterFunctionArguments": {
    "Rasters": [  //array of rasters
      <raster>,
      <raster>,
      <raster>
    ]
  },
  "outputPixelType": "<outputPixelType>",  //optional
  "variableName": "Raster"
}
```

#### ComputeChange

Introduced at 10.8.1, the `ComputeChange` function computes changes between two rasters. For more information, see Compute Change function. The difference (0), relative difference (1), and categorical (2) methods are for computing change between single-band rasters only. At 11.0, three methods for computing change between multiband rasters were added: Spectral Euclidean Distance (3), Spectral Angle Difference (4), and Band with Most Change (5).

<Note>

This function will only work if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "ComputeChange",
    "rasterFunctionArguments": {
      "Raster": <Raster>,  //the input raster
      "Raster2": <Raster2>,  //the input raster
      "Method": < Method>  //int, compute change method, 0 = difference, 1 = relative difference, 2 = categorical, 3 = Spectral Euclidean Distance, 4 = Spectral Angle Difference, 5 = Band with Most Change
    }
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "ComputeChange",
    "rasterFunctionArguments": {
      "Raster": "$1",
      "Raster2": "$2",
      "Method": 0
    }
  }
  ```
</Tab>

</Tabs>

#### ContrastBrightness

The `ContrastBrightness` function enhances the appearance of raster data (imagery) by modifying the brightness or contrast of the image. This function works on 8-bit input rasters only. For more information, see [Contrast and Brightness function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/contrastbrightness.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "ContrastBrightness",
    "rasterFunctionArguments": {
      "ContrastOffset": <ContrastOffset>,  //double, -100 to 100 
      "BrightnessOffset": <BrightnessOffset>,  //double, -100 to 100
      "Raster": <raster>  //optional, default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "ContrastBrightness",
    "rasterFunctionArguments": {
      "ContrastOffset": 30,
      "BrightnessOffset": 10,
      "Raster": "$$"
    }  
  }
  ```
</Tab>

</Tabs>

#### Convolution

The `Convolution` function filters the pixel values in an image, which can be used for sharpening an image, blurring an image, detecting edges in an image, or other kernel-based enhancements. For more information, see [Convolution function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/convolution.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Convolution",
    "rasterFunctionArguments": {
      "Columns": <Columns>,
      "Rows": <Rows>,
      "Kernel": [  //an array that has m x n elements
        <k11>,
        <k12>,
        ...
      ]
      "Type": <Type>,  //int (-1=UserDefined, 0=LineDetectionHorizontal, 1=LineDetectionVertical, 2=LineDetectionLeftDiagonal, 3=LineDetectionRightDiagonal, 4=GradientNorth, 5=GradientWest, 6=GradientEast, 7=GradientSouth, 8=GradientNorthEast, 9=GradientNorthWest, 10=SmoothArithmeticMean, 11=Smoothing3x3, 12=Smoothing5x5, 13=Sharpening3x3, 14=Sharpening5x5, 15=Laplacian3x3, 16=Laplacian5x5, 17=SobelHorizontal, 18=SobelVertical, 19=Sharpen, 20=Sharpen2, 21=PointSpread)    
      "Raster": <raster>  //optional, default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Convolution",
    "rasterFunctionArguments": {
      "Type": 11
    },
    "variableName": "Raster"
  }
  ```
</Tab>

</Tabs>

#### CreateColorComposite

Introduced at 11.0, the `CreateColorComposite` function creates a three-band raster from a multiband raster dataset in which each band can use an algebraic calculation based on band algebra. For more information, see [Create Color Composite function](https://doc.arcgis.com/en/arcgis-online/analyze/create-color-composite-function.htm).


<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {  "rasterFunction":"CreateColorComposite", 
    "rasterFunctionArguments": {   "Method":<0> or <1>,  // 0 – band names, 1 – band ids;  
    "BandIndexesR": <band name> or <band id> or <expression using bands>, // define for R band 
    "BandIndexesG": <band name> or <band id> or <expression using bands>, // define for G band 
    "BandIndexesB": <band name> or <band id> or <expression using bands>, // define for B band 
    "Raster": <raster>  // optional, default is the image service 
    } 
  }
  ```
</Tab>

<Tab>

  ```markdown
  { 
  "rasterFunction":"CreateColorComposite", 
    "rasterFunctionArguments": {    "Method":1,   
    "BandIndexesR":"B1", 
    "BandIndexesG":"B2", 
    "BandIndexesB":"B1-B2", 
    "Raster":"$$" 
    } 
  }
  ```
</Tab>

</Tabs>

#### Curvature

The `Curvature` function displays the shape or curvature of the slope. A part of a surface can be concave or convex; you can determine which by reviewing the curvature value. The curvature is calculated by computing the second derivative of the surface. For more information, see [Curvature function](https://pro.arcgis.com/en/pro-app/latest/arcpy/image-analyst/curvature.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Curvature",
    "rasterFunctionArguments": {
      "Type": <type>,  //0=Standard, 1=Platform, 2=Profile
      "ZFactor": <zFactor>,  //double
      "Raster": <Raster>  //optional, default is the service "$$"
    },
    "outputPixelType": "<outputPixelType>"//optional  
  }
  ```
</Tab>

<Tab>

  ```markdown
  { 
    "rasterFunction": "Curvature",
    "rasterFunctionArguments": {
      "Type": 0,
      "ZFactor": 1
    }
  }
  ```
</Tab>

</Tabs>

#### DetectChange

Introduced at 10.8.1, the `DetectChange` function generates a raster layer containing pixel change information using the output change analysis raster from the Analyze Changes Using CCDC tool. For more information, see [Detect Change Using Change Analysis function](https://doc.arcgis.com/en/arcgis-online/analyze/detect-change-using-change-analysis-function.htm).

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "DetectChange",
    "rasterFunctionArguments": {
      "Raster": <Raster>,  //the input raster
      "ChangeType": <ChangeType>,  //int, 0=time of latest change, 1=time of earliest change, 2=time of largest, 3=number of changes
      "MaxNumberChanges": <MaxNumberChanges>  //int
    }
  }
  ```
</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "DetectChange",
    "rasterFunctionArguments": {
      "Raster": "$$",
      "ChangeType": 0,
      "MaxNumberChanges": 1
    }
  }
  ```
</Tab>

</Tabs>

#### ElevationVoidFill

The `ElevationVoidFill` function creates pixels where holes exist in the elevation. For more information, see [Elevation Void Fill function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/elevationvoidfill.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "ElevationVoidFill",
    "rasterFunctionArguments": {
      "MaxVoidWidth": <MaxVoidWidth>,  //number. Maximum void width to fill. 0: fill all
      "Raster": <Raster>  //optional, default is the service "$$"
    },
    "outputPixelType": "<outputPixelType>"  //optional
  }
  ```
  <Note>

  `MaxVoidWidth` is used to specify the largest size of a void that you want to fill. The units of this parameter are the same as the units used in the spatial reference system.

  </Note>

</Tab>

<Tab>

  ```markdown
  { 
    "rasterFunction": "ElevationVoidFill",
    "rasterFunctionArguments": {
      "MaxVoidWidth": 0
    }
  }
  ```
</Tab>

</Tabs>

#### ExtractBand

The `ExtractBand` function allows you to extract one or more bands from a raster, or it can reorder the bands in a multiband image. For more information, see [Extract Band function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/extractband.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "ExtractBand",
    "rasterFunctionArguments": {
      "BandIDs": [<id>,<id>,<id>], //array of int
      "BandNames": ["<name>","<name","<name"], //array of string
      "BandWavelengths": [<wavelength>,<wavelength>,<wavelength>], //array of double
      "MissingBandAction": <act>, //int, 0=esriMissingBandActionFindBestMatch, 1=esriMissingBandActionFail
      "WavelengthMatchTolerance": <WavelengthMatchTolerance>, //double
      "Raster": <raster>  //optional default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
  <Note>

  `MaxVoidWidth` is used to specify the largest size of a void that you want to fill. The units of this parameter are the same as the units used in the spatial reference system.

  </Note>

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "ExtractBand",
    "rasterFunctionArguments": {
      "BandIDs": [3,2,1],
      "Raster": "$$"
    }  
  }
  ```
</Tab>

</Tabs>

#### Geometric

The `Geometric` function transforms the image (for example, `orthorectification`) based on a sensor definition and a terrain model. For more information, see [Geometric function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/geometric-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Geometric",
    "rasterFunctionArguments": {
      "GeodataTransforms": <GeodataTransform>,  //Refer to the Geodata Transformations documentation for more details.
      "AppendGeodataXform": <true|false>,  //boolean
      "ZFactor": <ZFactor>,  //double
      "ZOffset": <ZOffset>,  //double
      "ConstantZ": <ConstantZ>,  //double
      "CorrectGeoid": <true|false>,  //boolean
      "Raster":<raster>  //optional, default is the image service
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
  <Note>

  `MaxVoidWidth` is used to specify the largest size of a void that you want to fill. The units of this parameter are the same as the units used in the spatial reference system.

  </Note>

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Geometric",
    "rasterFunctionArguments": {
      "GeodataTransforms": [
        {
          "geodataTransform": "Polynomial",
          "geodataTransformArguments": {
            "sourcePoints": [
              {
                "x": 0,
                "y": 0
              },
              {
                "x": 0,
                "y": 200
              },
              {
                "x": 200,
                "y": 0
              }
            ],
            "targetPoints": [
              {
                "x": 100,
                "y": 100
              },
              {
                "x": 100,
                "y": 300
              },
              {
                "x": 300,
                "y": 100
              }
            ],
            "polynomialOrder": 1,
            "spatialReference": {
              "wkid": 54004
            }
          }
        }
      ],
      "AppendGeodataXform": true
    },
    "variableName": "Raster"
  }
  ```
</Tab>

</Tabs>

#### Grayscale

The `Grayscale` function converts a multiband image to a single-band grayscale image. Specified weights are applied to each input band, and a normalization is applied for output. For more information, see [Grayscale function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/grayscale.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Grayscale",
    "rasterFunctionArguments": {
      "conversionParameters": <array_of_double>,  //a length of N array representing weights for each band. N=band count.
      "Raster": <raster>  //optional, default is the image service
    }
  }
  ```

</Tab>

<Tab>

  ```other
  {
    "rasterfunction": "Grayscale",
    "rasterfunctionarguments": {
      "conversionparameters": [1,3,2],
      "raster": "$$"
    }
  }

  Output = (1 * Input_band_1 + 3 * Input_band_2 + 2 * Input_band_3)/(1 + 3 + 2);
  ```
</Tab>

</Tabs>

#### Hillshade

The `Hillshade` function produces a grayscale 3D model of the surface taking the sun's relative position into account to shade the image. For more information, see [Hillshade function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/hillshade-function.htm) and [How Hillshade works](https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-analyst-toolbox/how-hillshade-works.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Hillshade",
    "rasterFunctionArguments": {
      "HillshadeType": <HillshadeType>,  //new at 10.5.1.; 0=traditional, 1=multi-directional; default is 0.
      "Azimuth": <Azimuth>,  //double (e.g. 215.0)
      "Altitude": <Altitude>,  //double (e.g. 75.0)
      "ZFactor": <ZFactor>,  //double (e.g. 0.3)	
      "SlopeType": <SlopeType>,  //new at 10.2; 1=DEGREE, 2=PERCENTRISE, 3=SCALED; default is 1.	
      "PSPower": <PSPower>,  //new at 10.2. double, used together with SCALED slope type	
      "PSZFactor": <PSZFactor>,  //new at 10.2. double, used together with SCALED slope type	
      "RemoveEdgeEffect": <SlopeType>,  //new at 10.2. boolean, true of false 	
      "DEM": <raster>  //optional, default is the image service 	
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "DEM"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Hillshade",
    "rasterFunctionArguments": {
      "Azimuth": 215.0,
      "Altitude": 75.0,
      "ZFactor": 0.3
    },
    "variableName": "DEM"
  }
  ```
</Tab>

</Tabs>

#### Identity

The `Identity` function defines the source raster as part of the default mosaicking behavior of the mosaic dataset. It is a no-op function and takes no arguments except a raster. For more information, see [Identity function](https://desktop.arcgis.com/en/arcmap/latest/tools/analysis-toolbox/identity.htm).

  ```markdown label=Syntax
  {
    "rasterFunction": "Identity",
    "rasterFunctionArguments": {
      "Raster": <raster>
    }
  }
  ```

  #### Local

  The `Local` function performs bitwise, conditional, logical, mathematical, and statistical operations on a pixel-by-pixel basis. The `Local` function works on single-band imagery or the first band of an image only, and the output is single band. For more information, see [Local function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/local-function.htm). There are many operations supported by the `Local` function, see [esriGeoAnalysisFunctionEnum Constants](https://resources.arcgis.com/en/help/arcobjects-net/componentHelp/index.html#//004000000149000000) for more information.

<Note>

ArcGIS Server must be licensed as ArcGIS Server Enterprise Advanced or ArcGIS Image Server to use this resource. For earlier versions, the hosting ArcGIS Server installation must have an ArcGIS Spatial Analyst extension license.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Local",
    "rasterFunctionArguments": {
      "Operation": <operation>,  //int see reference below.
      "Rasters": [<raster1>, <raster2>, <raster3>],  //array of rasters. If a scalar is needed for the operation the scalar can be in double or string
      "ExtentType": <ExtentType>,  //int, optional, default 0. 0=esriExtentFirstOf, 1=esriExtentIntersectionOf, 2=esriExtentUnionOf, 3=esriExtentLastOf 
      "CellsizeType": <CellsizeType>,//int, optional, default 0. 0=esriCellsizeFirstOf, 1=esriCellsizeMinOf, 2=esriCellsizeMaxOf, 3=esriCellsizeMeanOf, 4=esriCellsizeLastOf
      "ProcessAsMultiband": <true|false>, //boolean, optional, default is true. When set as false it will treat the input multiband raster as multiple 1-band rasters when performing cell statistics operations (for operations: 38~43, 47, 54, 55, 58, 66~75)
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",//optional
    "variableName": "Rasters"//optional
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Local",
    "rasterFunctionArguments": {
      "Operation": 2,
      "Rasters": ["$$",100]
    }  
  }
  ```
</Tab>

</Tabs>

#### Mask

The `Mask` function changes the image by specifying a pixel value or a range of pixel values as no data. For more information, see [Mask function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/mask-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Mask",
    "rasterFunctionArguments": {
      "NoDataValues": [  //array of string
        "band0_val",
        "band1_val",
        ...
      ],
      "IncludedRanges": [  //array of double
        band0_lowerbound,
        band0_upperbound,
        band1
        ...
      ],
      "NoDataInterpretation": <NoDataInterpretation>,  //int 0=esriNoDataMatchAny, 1=esriNoDataMatchAll
      "Raster": <raster>  //optional, default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Mask",
    "rasterFunctionArguments": {
      "NoDataValues": ["-100"],
      "IncludedRanges": [-800,100],
      "NoDataInterpretation": 0
    },  
    "variableName": "Raster"
  }
  ```
</Tab>

</Tabs>

#### MLClassify

The `MLClassify` function performs a supervised classification using the maximum likelihood classification algorithm. The hosting ArcGIS Server installation must have an ArcGIS Spatial Analyst extension license. For more information, see [MLClassify](https://pro.arcgis.com/en/pro-app/latest/arcpy/image-analyst/mlclassify.htm).

<Note>

ArcGIS Server must be licensed as ArcGIS Server Enterprise Advanced or ArcGIS Image Server to use this resource. For earlier versions, the hosting ArcGIS Server installation must have an ArcGIS Spatial Analyst extension license.

</Note>

```markdown
{
  "rasterFunction": "MLClassify",
  "rasterFunctionArguments": {
    "SignatureFile": "<signature>",  //string. a signature string returned from computeClassStatistics (GSG)
    "Raster": <raster>  //optional, default is the image service 
  },
  "outputPixelType": "<outputPixelType>",  //optional
  "variableName": "Raster"
}
```

#### MultidimensionalRaster

Introduced at 10.8.1, the `MultidimensionalRaster` function adds a multidimensional dataset, such as NetCDF, GRIB, and HDF data; a multidimensional mosaic dataset; or a multidimensional CRF to a multidimensional raster. For more information, see [Multidimensional Raster function](https://doc.arcgis.com/en/arcgis-online/analyze/multidimensional-raster.htm).

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "MultidimensionalRaster",
    "rasterFunctionArguments": {
      "Variables": [   //array of string
        "<variable1_name>",
        "<variable2_name",
        …
      ]
      "InterpolationMethod": <int>,  //optional, used when the input raster is not regular grids. 0="Nearest Neighbor", 1="Linear Tinning", 2="Natural Neighbor", and 3="Inverse Distance Weighted". Default value is 0 .
      "InterpolationCellsize": <double>,  //optional, used when the input raster is not regular grids. Defines the cell size of the output raster. Default value = 1
      "Raster": <raster>  //optional, default is the image service
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "MultidimensionalRaster",
    "rasterFunctionArguments": {
      "Variables": [
        "salinity",
        "water_temp"
      ]
      "Raster": "$$"
    }
  }
  ```
</Tab>

</Tabs>

#### MultidimensionalFilter

Introduced at 10.8.1, the `MultidimensionalFilter` function filters a multidimensional raster using specified variables and dimensions. For more information, see [Multidimensional Filter function](https://doc.arcgis.com/en/arcgis-online/analyze/multidimensional-filter.htm).

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
  <TabTitle>Example 3</TabTitle>
  <TabTitle>Example 4</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "MultidimensionalFilter",
    "rasterFunctionArguments": {
      "Filter": <filter_json>,  //a json object that defines the filter definition. 
      "Raster": <raster>  //optional, default is the image service
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

This example demonstrates how to filter a raster using two variables, `salinity` and `surf_el`, with all slices.

  ```markdown
  {
    "rasterFunction": "MultidimensionalFilter",
    "rasterFunctionArguments": {
      "Filter": {
        "variables": [
          "salinity",
          "surf_el"
        ],
        "definitionType": "ALL"
      },
      "Raster": "$$"
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to filter a raster using two variables, `salinity` and `surf_el`, with slices having `StdTime` as `"2013-05-17T00:00:00"` and `"2013-05-17T15:00:00"`.

  ```markdown
  {
    "rasterFunction": "MultidimensionalFilter",
    "rasterFunctionArguments": {
      "Filter": {
        "variables": [
          "salinity",
          "surf_el"
        ],
        "definitionType": "BY_VALUES",
        "dimensions": [
          "StdTime",
          "StdTime"
        ],
        "values": [
          "2013-05-17T00:00:00",
          "2013-05-17T15:00:00"
        ]
      },
      "Raster": "$$"
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to filter a raster using two variables, `salinity` and `surf_el`, with slices having `StdTime` in the [`"2013-05-17T00:00:00"`, `"2013-05-17T12:00:00"`] range and `StdZ` in the `[-40, 0]` range.

  ```markdown
  {
    "rasterFunction": "MultidimensionalFilter",
    "rasterFunctionArguments": {
      "Filter": {
        "variables": [
          "salinity",
          "surf_el"
        ],
        "definitionType": "BY_RANGES",
        "dimensions": [
          "StdTime",
          "StdZ"
        ],
        "minValues": [
          "2013-05-17T03:00:00",
          "-40"
        ],
        "maxValues": [
          "2013-05-17T12:00:00",
          "0"
        ]
      },
      "Raster": "$$"
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to filter a raster using two variables, `salinity` and `surf_el`, with slices having `StdTime` and stepping from `"2013-05-17T03:00:00"` to `"2013-05-18T18:00:00"` every three hours.

  ```markdown
  {
    "rasterFunction": "MultidimensionalFilter",
    "rasterFunctionArguments": {
      "Filter": {
        "variables": [
          "salinity",
          "surf_el"
        ],
        "definitionType": "BY_ITERATION",
        "dimension": "StdTime",
        "startValue": "2013-05-17T03:00:00",
        "endValue": "2013-05-18T18:00:00",
        "stepValue": 3,
        "units": "HOURS"
      },
      "Raster": "$$"
    }
  }
  ```
</Tab>

</Tabs>

#### NDVI

The Normalized Difference Vegetation Index (`NDVI`) object is a standardized index that allows you to generate an image displaying greenness (relative biomass). This index uses the contrast of the characteristics of two bands from a multispectral raster dataset—the chlorophyll pigment absorptions in the red band and the high reflectivity of plant materials in the near-infrared (NIR) band. The `NDVI` function detects relative biomass (greenness) in a raster image. For more information, see [NDVI function](https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/ndvi.htm).

The following equation is used by the `NDVI` function to generate a 0–200 range 8 bit result:

```other
NDVI = ((IR - R)/(IR + R)) * 100 + 100
```

If you need the specific pixel values (-1.0 to 1.0), use the BandArithmetic function and choose the NDVI method.

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "NDVI",
    "rasterFunctionArguments": {
      "VisibleBandID": <VisibleBandID>,  //int (zero-based band id, e.g. 2)
      "InfraredBandID": <InfraredBandID>,  //int (zero-based band id, e.g. 1)
      "Raster": <raster>  //optional, default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "NDVI",
    "rasterFunctionArguments": {
      "VisibleBandID": 2,
      "InfraredBandID": 1
    },
    "variableName": "Raster"
  }
  ```
</Tab>

</Tabs>

#### Pansharpening

The `Pansharpening` function uses a higher-resolution panchromatic raster to fuse with a lower-resolution multiband raster. It can generate a colorized multispectral image with higher resolution. For more information, see [Pan-sharpening function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/pansharpening-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Pansharpening",
    "rasterFunctionArguments": {
      "Weights": <array_of_double>,  //Weights applied for Red, Green, Blue, Near-Infrared bands. 4-elements array, Sum of values is 1.
      "PansharpeningType": <int>,  //Pansharpening method, 0:IHS; 1:Brovey; 2:Esri; 3:Simple Mean; 4:Gram-Schmidt. 
      "PanImage": <raster>,
      "MSImage": <raster>,
      "InfraredImage": <raster>,  //optional if "UseFourthBandOfMSAsIR" is true or selected pansharpening method doesn’t require near-infrared image.
      "UseFourthBandOfMSAsIR": <true|false>,  //true if "MSImage" has near-infrared image on fourth band.
      "Sensor": <string>,  //optional sensor name.
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates the `Pansharpening` function using Landsat 8 data with the Gram-Schmidt method. The image service is published from the Landsat 8 mosaic dataset `"$oid"="$band_number"`.

  ```markdown
  {
    "rasterFunction": "Pansharpening",
    "rasterFunctionArguments": {
      "Weights": [
        0.42,
        0.51,
        0.07,
        0
      ],
      "PansharpeningType": 4,
      "PanImage": "$8",
      "MSImage": {
        "rasterFunction": "CompositeBand",
        "rasterFunctionArguments": {
          "Rasters": [
            "$4",
            "$3",
            "$2",
            "$5"
          ]
        }
      },
      "UseFourthBandOfMSAsIR": false
    }
  }
  ```
</Tab>

</Tabs>

#### ProcessRasterCollection

Introduced at 10.8.1, the `ProcessRasterCollection` function processes each slice in a multidimensional raster or each item in a mosaic raster using different functions. This function can also aggregate multiple slices into a single slice. For more information including supported operators, see [Process Raster Collection function](https://doc.arcgis.com/en/arcgis-online/analyze/process-raster-collection.htm).

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
  <TabTitle>Example 3</TabTitle>
  <TabTitle>Example 4</TabTitle>
  <TabTitle>Example 5</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {	
    "rasterFunction": "ProcessRasterCollection",
    "rasterFunctionArguments": {
      "ItemFunction": <function_template_file>,  // optional, the path to a function template file (.rft.xml) to process each slice or each item in the raster
      "AggregationFunction": <function_template_file>,  // optional, the path to a function template file (.rft.xml) to aggregate multiple slices into a single slice
      "ProcessingFunction": <function_template_file>,  // optional, the path to a function template file (.rft.xml) to process the raster , e.g., add a colormap to render
      "AggregationDefinition": < json >, // optional, used when AggregationFunction is specified. Keys include "definitionType"(Type), "dimension"(Dimension), "intervalKeyword"(Keyword Interval), "intervalValue"(Value Interval), "intervalUnits"(Unit), "minValues"(Minimum Value), "maxValues"(Maximum Value). Allowed values for each key are listed inside [Process Raster Collection function](https://doc.arcgis.com/en/arcgis-online/analyze/process-raster-collection.htm).
      "Raster": <raster>
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to calculate the NDVI for each scene, return the maximum NDVI value across different items, and apply an NDVI color map.

  ```markdown
  {	
    "rasterFunction": "ProcessRasterCollection",
    "rasterFunctionArguments": {
      "ItemFunction": "/fileShares/rft/NDVI.rft.xml",
      "AggregationFunction": "/fileShares/rft/CellStatisticsMax.rft.xml",
      "AggregationDefinition": {
        "definitionType": "ALL",
        "dimension": "StdTime"
      },
      "ProcessingFunction": "/fileShares/rft/Colormap.rft.xml",
    "Raster":  "$$"
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to calculate the maximum temperature across all time slices.

  ```markdown
  {	
    "rasterFunction": "ProcessRasterCollection",
    "rasterFunctionArguments": {
      "AggregationFunction": "/fileShares/rft/CellStatisticsMax.rft.xml",
      "AggregationDefinition": {"definitionType":"ALL","dimension":"StdTime"},
      "Raster": "$$"
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to calculate the maximum temperature per year.

  ```markdown
  {	
    "rasterFunction": "ProcessRasterCollection",
    "rasterFunctionArguments": {
      "AggregationFunction": "/fileShares/rft/CellStatisticsMax.rft.xml",
      "AggregationDefinition": {
        "definitionType": "INTERVAL_KEYWORD",
        "dimension": "StdTime",
        "intervalKeyword": "YEARLY"
      }, 
      "Raster":  "$$"
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to calculate the maximum temperature within the [`2001-01-01T00:00:00`, `2008-01-01T00:00:00`] range.

  ```markdown
  {	
    "rasterFunction": "ProcessRasterCollection",
    "rasterFunctionArguments": {
      "AggregationFunction":  "/fileShares/rft/CellStatisticsMax.rft.xml",
      "AggregationDefinition": {
        "definitionType": "INTERVAL_RANGES",
        "dimension": "StdTime",
        "minValues": ["2001-01-01T00:00:00"],
        "maxValues": ["2008-01-01T00:00:00"]
      },
      "Raster": "$$"
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to calculate the maximum temperature every five days.

  ```markdown
{	
  "rasterFunction": "ProcessRasterCollection",
  "rasterFunctionArguments": {
    "AggregationFunction": "/fileShares/rft/CellStatisticsMax.rft.xml",
    "AggregationDefinition": {
      "definitionType": "INTERVAL_VALUE",
      "dimension": "StdTime",
      "intervalValue": 5,
      "intervalUnits": "DAYS"
    }, 
    "Raster": "$$"
  }
}
  ```
</Tab>

</Tabs>

#### RasterCalculator

The `RasterCalculator` function provides access to all existing math functions so you can make calls to them when building expressions. The `RasterCalculator` function requires single-band inputs. To perform expressions on bands in a multispectral image as part of a function chain, you can use the `ExtractBandfunction` before the `RasterCalculator` function. For more information including supported operators, see [Calculator function](https://doc.arcgis.com/en/arcgis-online/analyze/calculator-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "RasterCalculator",
    "rasterFunctionArguments": {
      "InputNames": [  //array of strings for arbitrary raster names
        "raster1_Name",
        "raster2_Name",
        "raster3_Name",
        …
      ],
      "Expression": "raster1_Name + raster2_Name - raster3_Name",  //string, expression to calculate output raster from input rasters
      "ExtentType": <ExtentType>,  //int, optional, default 0; 0=esriExtentFirstOf, 1=esriExtentIntersectionOf, 2=esriExtentUnionOf, 3=esriExtentLastOf 
      "CellsizeType": <CellsizeType>,  //int, optional, default 0; 0=esriCellsizeFirstOf, 1=esriCellsizeMinOf, 2=esriCellsizeMaxOf, 3=esriCellsizeMeanOf, 4=esriCellsizeLastOf
      "Rasters": [  //array of rasters
        <raster1>,
        <raster2>,
        <raster3>,
        …
      ],
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "RasterCalculator",
    "rasterFunctionArguments": { 
      "InputNames": [
        "a1",
        "name2"
      ],
      "Expression": "a1+name2",
      "ExtentType": 0,
      "CellsizeType": 1,
      "Rasters": [
        "$1",
        "$2"
      ]
    }
  }
  ```
</Tab>

</Tabs>

#### Recast

The `Recast` function reassigns argument values in an existing function template. For more information, see [Recast function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/recast-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Recast",
    "rasterFunctionArguments": {
      "<ArgumentName1>": <ArgumentValue1>,  //ArgumentName1 will be reassigned with ArgumentValue1
      "<ArgumentName2>": <ArgumentValue2>  //ArgumentName1 will be reassigned with ArgumentValue2
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

This example demonstrates how to view the high vegetation and buildings class of a particular LAS in a mosaic. The following LAS ClassTypes options can be used in REST API with the Recast function:

* 0: Never Classified
* 1: Unclassified
* 2: Ground
* 3: Low Vegetation
* 4: Medium Vegetation
* 5: High Vegetation
* 6: Building
* 7: Noisy Low Point
* 8: Model Key Point
* 9: Water
* 10: Rail
* 11: Road Surface
* 12: Reserved
* 13: Wire guard
* 14: Wire conductor
* 15: Transmission tower
* 16: Wire structure connector
* 17: Bridge deck
* 18: High noise

  ```markdown
  {
    "mosaicMethod": "esriMosaicLockRaster",
    "lockRasterIds": [1],
    "ascending": true,
    "mosaicOperation": "MT_FIRST",
    "itemRenderingRule": {
      "rasterFunction": "Recast",
      "rasterFunctionArguments": {
        "ClassTypes": [5,6]
      }
    }
  }
  ```
</Tab>

<Tab>

This example demonstrates how to change the z-factor of an existing hillshade function on the first raster in the service.

  ```markdown
  {
    "rasterFunction": "Recast",
    "rasterFunctionArguments": {
      "ZFactor": 3.5,
      "Raster": "$1"
    }  
  }
  ```

</Tab>

</Tabs>

#### Remap

The `Remap` function changes or reclassifies the pixel values of the raster data. For more information, see [Remap function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/remap-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Remap",
    "rasterFunctionArguments": {
      "InputRanges": [  //[double, double,…], input ranges are specified in pairs: from (inclusive) and to (exclusive).
        <value1_from>,
        <value1_to>,
        …
      ],
      "OutputValues": [ //[double, …], output values of corresponding input ranges
        <value1>,
        …
      ],
      "GeometryType": <geometryType>,  //added at 10.3
      "Geometries": [  //added at 10.3
        <geometry1>,
        <geometry2>,
        ...
      ],
      "NoDataRanges": [  //[double, double, …], nodata ranges are specified in pairs: from (inclusive) and to (exclusive).
        <nodatavalue1_from>,
        <nodatavalue1_to>,
        …
      ],
      "AllowUnmatched": <true|false>,  //Boolean, specify whether to keep the unmatched values or turn into nodata.
      "Raster": <raster>  //optional, default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

This example demonstrates how to remap pixel values.

  ```markdown
  {
    "rasterFunction": "Remap",
    "rasterFunctionArguments": {
      "InputRanges": [
        0,
        100,
        101,
        200
      ],
      "OutputValues": [
        5,
        125
      ]
    },
    "variableName": "Raster"
  }
  ```
</Tab>

<Tab>

This example demonstrates how to use the Remap function with geometry values

  ```markdown
  {
    "rasterFunction": "Remap",
    "rasterFunctionArguments": {
      "InputRanges": [50, 51],
      "OutputValues": [71],
      "GeometryType": "esriGeometryEnvelope",
      "Geometries": [
        {
          "spatialReference": {
            "wkid": 2264
          },
          "rings": [
            [
              [1432285, 529578],
              [1436048, 529578],
              [1434048, 531578],
              [1433285, 533205],
              [1432285, 529578]
            ]
          ]
        }
      ]
    }
  }
  ```

</Tab>

</Tabs>

#### Resample

The `Resample` function resamples pixel values from a given resolution. For more information, see [Resample function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/resample-function.htm).

Use this function only if the workflow has specific computing requirements, such as computing average wind magnitude-direction. Resampling from a designated resolution can be much slower than the default behavior (nearest resolution). In most cases, using the `interpolation` parameter in the Export Image operation is sufficient.

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Resample",
    "rasterFunctionArguments": {
      "ResamplingType": <ResamplingType>,  //0=NearestNeighbor, 1=Bilinear, 2=Cubic, 3=Majority, 4=BilinearInterpolationPlus, 5=BilinearGaussBlur, 6=BilinearGaussBlurPlus, 7=Average, 8=Minimum, 9=Maximum, 10=VectorAverage (require two bands)
      "InputCellsize": <InputCellsize>  //point that defines cellsize in source spatial reference
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
  <Note>

  `InputCellsize` only supports source spatial reference.

  </Note>

</Tab>

<Tab>

This example demonstrates how to resample a wind magnitude-direction raster using vector average from base resolution.

  ```markdown
  {
    "rasterFunction": "Resample",
    "rasterFunctionArguments": {
      "ResamplingType": 10,
      "InputCellsize": {
        "x": 0.125,
        "y": 0.125
      }
    }
  }
  ```
</Tab>

</Tabs>

#### SegmentMeanShift

The `SegmentMeanShift` function produces a segmented output. Pixel values in the output image represent the converged RGB colors of the segment. The input raster must be a three-band 8-bit image. If the image service is not a three-band 8-bit unsigned image, you can use the Stretch function before the `SegmentMeanShift` function. For more information, see [Segment Mean Shift function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/segment-mean-shift-function.htm).

<Note>

At 10.5, ArcGIS Server must be licensed as ArcGIS Server Enterprise Advanced or ArcGIS Image Server to use this resource. For earlier versions, the hosting ArcGIS Server installation must have an ArcGIS Spatial Analyst extension license.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "SegmentMeanShift",
    "rasterFunctionArguments": {
      "SpectralDetail": <SpectralDetail>,  //double 0-21. Bigger value is faster and has more segments.
      "SpatialDetail": <SpatialDetail>,  //int 0-21. Bigger value is faster and has more segments.
      "SpectralRadius": <MaxValue>,  //double. Bigger value is slower and has less segments.
      "SpatialRadius": <MaxValue>,  //int. Bigger value is slower and has less segments.
      "MinNumPixelsPerSegment": <MinNumPixelsPerSegment>,  //int
      "Raster": <Raster>  //the raster to be segmented. optional, default is the service.
    },
    "outputPixelType": "<outputPixelType>",  //optional
  }
  ```
  <Note>

  When specifying arguments for `SegmentMeanShift`, use either `SpectralDetail,SpatialDetail` as a pair or `SpectralRadius, SpatialRadius`. They have an inverse relationship (`SpectralRadius = 21 - SpectralDetail`, `SpatialRadius = 21 - SpectralRadius`).

  </Note>

</Tab>

<Tab>

This example demonstrates how to segment an image.

  ```markdown
  {
    "rasterFunction": "SegmentMeanShift",
    "rasterFunctionArguments": {
      "SpectralDetail": 15.5,
      "SpatialDetail": 15,
      "MinNumPixelsPerSegment": 20,
      "Raster": "$$"
    }  
  }
  ```
</Tab>

</Tabs>

#### ShadedRelief

The `ShadedRelief` function creates a color 3D model of the terrain by merging the images from the elevation-coded and hillshade methods. For more information, see [Shaded Relief function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/shaded-relief-function.htm). You can specify a `colormap` or `colorramp` value to render the shaded relief results. For more predefined color ramps, see the `colorrampname` parameter in the colormap raster function.

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "ShadedRelief",
    "rasterFunctionArguments": {
      "HillshadeType": <HillshadeType>,  //new at 10.8.1. 0=Traditional, 1=Multidirectional. Default is 0.
      "Azimuth": <Azimuth>,  //double (e.g. 215.0)
      "Altitude": <Altitude>,  //double (e.g. 75.0)
      "ZFactor": <ZFactor>,  //double (e.g. 0.3)
      "Colormap": [
        [<value1>, <red1>, <green1>, <blue1>],  //[int, int, int, int]
        [<value2>, <red2>, <green2>, <blue2>]
      ],
      "Colorramp": "<Black To White | Yellow To Red | Slope | more…>"
      "SlopeType": <SlopeType>,  //new at 10.2. 1=DEGREE, 2=PERCENTRISE, 3=SCALED. default is 1.	
      "PSPower": <PSPower>,  //new at 10.2. double, used together with SCALED slope type	
      "PSZFactor": <PSZFactor>,  //new at 10.2. double, used together with SCALED slope type	
      "RemoveEdgeEffect": <SlopeType>,  //new at 10.2. boolean, true of false 	
      "Raster": <raster>  //optional, default is the image service 	
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```
  <Note>

  When specifying arguments for `SegmentMeanShift`, use either `SpectralDetail,SpatialDetail` as a pair or `SpectralRadius, SpatialRadius`. They have an inverse relationship (`SpectralRadius = 21 - SpectralDetail`, `SpatialRadius = 21 - SpectralRadius`).

  </Note>

</Tab>

<Tab>

This example demonstrates how to segment an image.

  ```markdown
  {
    "rasterFunction": "ShadedRelief",
    "rasterFunctionArguments": {
      "Azimuth": 215.0,
      "Altitude": 75.0,
      "ZFactor": 0.3,
      "Colormap": [
        [1, 255, 0, 0],
        [2, 0, 255, 0],
        [3, 125, 25, 255],
        ...
      ],
      "Raster": <raster>
    },
    "variableName": "Raster"
  }
  ```
</Tab>

</Tabs>

#### Slope

`Slope` represents the rate of change of elevation for each pixel. For more information, see [Slope function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/slope-function.htm) and [How Slope works](https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-analyst-toolbox/how-slope-works.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Slope",
    "rasterFunctionArguments": {
      "ZFactor": <ZFactor>  //double (e.g. 0.3)
      "SlopeType": <SlopeType>,  //new at 10.2. 1=DEGREE, 2=PERCENTRISE, 3=SCALED. default is 1.	
      "PSPower": <PSPower>,  //new at 10.2. double, used together with SCALED slope type	
      "PSZFactor": <PSZFactor>,  //new at 10.2. double, used together with SCALED slope type	
      "RemoveEdgeEffect": <RemoveEdgeEffect>  //new at 10.2. boolean, true or false, default is false.
      "DEM": <raster>  //optional, default is the image service 	
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "DEM"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Slope",
    "rasterFunctionArguments": {
      "ZFactor": 0.3
    }
  }
  ```
</Tab>

</Tabs>

#### Speckle

The `Speckle` function filters the speckled radar dataset to smooth out the noise while retaining the edges or sharp features in the image. Four speckle reduction filtering algorithms are provided through this function. For more information including required and optional parameters for each filter and the default parameter values, see [Speckle function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/speckle-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Speckle",
    "rasterFunctionArguments": {
      "FilterType": <int>,  //0=Lee, 1=Enhanced Lee, 2=Frost, 3=Kuan
      "FilterSize": <int>,  //kernel size. 0=3x3, 1=5x5, 2=7x7, 3=9x9, 4=11x11
      "NoiseModel": <int>,  //for Lee filter only. 0: Multiplicative Noise, 1: Additive Noise, 2: Additive and Multiplicative Noise
      "NoiseVar": <double>,  //for Lee filter with NoiseModel 1 or 2 only.
      "AdditiveNoiseMean": <double>  //for lee filter with NoiseModel 2 only.
      "MultiplicativeNoiseMean": <double>,  //for lee filter with NoiseModel 0 or 2 only.
      "NLooks": <int>,  //for Lee, Enhanced Lee, and Kuan filters.
      "DampFactor": <double>,  //for Enhanced Lee and Frost filters.
      "Raster": <raster>
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to despeckle a radar image service with the Lee filter.

  ```markdown
  {
    "rasterFunction": "Speckle",
    "rasterFunctionArguments": {
      "FilterType": 0,
      "FilterSize": 4,
      "NoiseModel": 0,
      "MultiplicativeNoiseMean": 1,
      "NLooks": 1,
      "Raster": "$$"
    }
  }
  ```
</Tab>

</Tabs>

#### SpectralConversion

The `SpectralConversion` function applies a matrix to a multiband image to affect the spectral values of the output. In the matrix, different weights can be assigned to all the input bands to calculate each output band. The column and row size of the matrix equals the band count of the input raster. For more information, see [Spectral Conversion function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/spectral-conversion-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "SpectralConversion",
    "rasterFunctionArguments": {
      "ConversionMatrix": <array_of_double>,  //a NxN length one-dimension matrix. N=band count.
      "Raster": <raster>  //optional, default is the image service
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to despeckle a radar image service with the Lee filter.

  ```markdown
  {
    "rasterfunction": "SpectralConversion",
    "rasterfunctionarguments": {
      "conversionmatrix": [0.3,0.2,0.5,0,1,0,1,0,0],
      "raster": "$$"
    }
  }
  ```

  The following shows how numbers in the conversion matrix will be used:

  ```markdown
  Output band_1 = 0.3 * Input_band_1 + 0.2 * Input_band_2 + 0.5 * Input_band_3;
  Output band_2 = 0 * Input_band_1 + 1 * Input_band_2 + 0 * Input_band_3;
  Output band_3 = 1 * Input_band_1 + 0 * Input_band_2 + 0 * Input_band_3;
  ```

</Tab>

</Tabs>

#### SpectralUnmixing

Introduced at 10.8.1, the `SpectralUnmixing` function classifies subpixels and calculates the fractional abundance of land-cover types for individual pixels. For more information including supported operators, see [Linear Spectral Unmixing function](https://doc.arcgis.com/en/arcgis-online/analyze/linear-spectral-unmixing.htm).

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "SpectralUnmixing",
    "rasterFunctionArguments": {
      "SpectralProfileType": <int>,  //0=using Spectral profile file, value, 1=using training feature 
      "SpectralProfileFile": <string>,  //the path to a ECD file or a JSON file. Optional, used when SpectralProfileType is 0. 
      "TrainingFeature": <string>,  //the path to a training feature dataset. used when SpectralProfileType is 1.
      "SpectralProfileDefinition": <json>,  //a json object that defines the spectral profile parameters.
      "NonNegative": <bool>,  //constrains the outputs to be non-negative. Default: False
      "SumToOne": <bool>,  //constrains the outputs to sum to one. Default: False
      "Raster": <raster>  //optional, default is the image service
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

This example demonstrates how to use the `SpectralUnmixing` function with the `SpectralProfile` definition for linear spectral unmixing.

  ```markdown
  {
    "rasterFunction": "SpectralUnmixing",
    "rasterFunctionArguments": {
      "NonNegative": true, 
      "SumToOne": true,
      "Raster": "$$",
      "SpectralProfileDefinition": {  
        "EsriClassifierDefinitionFile": 0,
        "FileVersion": 3, 
        "NumberDefinitions": 1, 
        "Definitions": [
          {
            "Classifier": "MaximumLikelihood",
            "NumberClasses": 2,  
            "RasterIsSegmented": false,  
            "NumberBands": 3,
            "Classes": [ 
              {
                "ClassValue": 1,
                "ClassName": "Vegetation",
                "Red": 230,
                "Green": 0,
                "Blue": 0, 
                "Count": 546, 
                "Means": [
                  244.9359,
                  14.88278,
                  15.21978
                ],
                "Covariances": [
                  [
                    10.26146,
                    0.1390063,
                    0.1074951
                  ],
                  [
                    0.1390063,
                    10.31593,
                    1.207584E-04
                  ],
                  [
                    0.1074951,
                    1.207584E-04,
                    10.19345
                  ]
                ]
              },
              {
                "ClassValue": 2,
                "ClassName": "Water",
                "Red": 0,
                "Green": 77,
                "Blue": 168,
                "Count": 716,
                "Means": [
                  15.05587,
                  15.01257,
                  244.9567
                ],
                "Covariances": [
                  [
                    10.18124,
                    0.1152196,
                    0.2789551
                  ],
                  [
                    0.1152196,
                    10.02638,
                    -0.3583943
                  ],
                  [
                    0.2789551,
                    -0.3583943,
                    110.11684
                  ]
                ]
              }
            ]
          }
        ]
      }
    }  
  }
  ```

</Tab>

</Tabs>


#### Statistics

The `Statistics` function calculates focal statistics for each pixel of an image based on a defined focal neighborhood. For more information, see [Statistics function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/statistics-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>
Two syntax formtas are supported: 
  ```markdown
  {
    "rasterFunction": "Statistics",
    "rasterFunctionArguments": {
      "Type": "<Min | Max | Mean | StandardDeviation>",
      "KernelColumns": <KernelColumns>,  //int (e.g. 3)
      "KernelRows": <KernelRows>  //int (e.g. 3)
      "Raster": <raster>  //optional, default is the image service 
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

  ```markdown
  {
  "rasterFunction": "Statistics",
  "rasterFunctionArguments": {
    "Type": <Type>,  //int 1=Min, 2=Max, 3=Mean, 4=StandardDeviation
    "Columns": <Columns>,  //int (e.g. 3)
    "Rows": <Rows>,  //int (e.g. 3)
    "FillNoDataOnly": <fillNoDataOnly>,  //bool
    "Raster": <raster>  //optional, default is the image service 
  },
  "outputPixelType": "<outputPixelType>",  //optional
  "variableName": "Raster"
}
```

</Tab>

<Tab>

This example demonstrates how to use the `SpectralUnmixing` function with the `SpectralProfile` definition for linear spectral unmixing.

  ```markdown
  {
    "rasterFunction": "Statistics",
    "rasterFunctionArguments": {
      "Type": "Mean",
      "KernelColumns": 3,
      "KernelRows": 3
    },
    "variableName": "Raster"
  }
  ```

</Tab>

</Tabs>

#### StatisticsHistogram

The `StatisticsHistogram` function defines the statistics and histogram of a raster. It is typically used to control the default display of an exported image. For more information, see [Statistics and Histogram function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/statistics-and-histogram-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

Two syntax formtas are supported: 

  ```markdown
  {
    "rasterFunction": "StatisticsHistogram",
    "rasterFunctionArguments": {
      "Statistics": <array of statistics objects>,  //predefined statistics for each band
      "Histograms": <array of histogram objects>,  //predefined histograms for each band
      "Raster": <raster>  //optional, default is the image service
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to use the `SpectralUnmixing` function with the `SpectralProfile` definition for linear spectral unmixing.

  ```markdown
  {
    "rasterFunction": "StatisticsHistogram",
    "rasterFunctionArguments": {
      "statistics": [
        {
          "min": 0,
          "max": 23.064547000000001,
          "mean": 4.547517,
          "standardDeviation": 2.6870280000000002,
          "count": 10000,
          "median": 5,
          "mode": 6
        }
      ],
      "histograms": [
        {
          "size": 256,
          "min": 0,
          "max": 23.064547032777931,
          "counts": [
            559,
            172,
            217,
            ... //256 elements for each of the bins in this example
          ]
        }
      ]
    }
  }
  ```

</Tab>

</Tabs>

#### Stretch

The `Stretch` function enhances an image through multiple stretch types. For more information, see [Stretch function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/stretch-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>StandardDeviation</TabTitle>
  <TabTitle>MinMax</TabTitle>
  <TabTitle>PercentClip</TabTitle>
  <TabTitle>None</TabTitle>
  <TabTitle>HistogramEqualization</TabTitle>
  <TabTitle>Sigmoid</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "StatisticsHistogram",
    "rasterFunctionArguments": {
      "statistics": [
        {
          "min": 0,
          "max": 23.064547000000001,
          "mean": 4.547517,
          "standardDeviation": 2.6870280000000002,
          "count": 10000,
          "median": 5,
          "mode": 6
        }
      ],
      "histograms": [
        {
          "size": 256,
          "min": 0,
          "max": 23.064547032777931,
          "counts": [
            559,
            172,
            217,
            ... //256 elements for each of the bins in this example
          ]
        }
      ]
    }
  }
  ```
The `Gamma` stretch works with all stretch types. The `Gamma` parameter is needed when `UseGamma` is set to `true`. `Min` and `Max` can be used to define minimum and maximum output . `DRA` is used to get statistics from the extent in the Export Image operation. `ComputeGamma` automatically calculates the best gamma value to render an exported image based on the empirical model. Stretch type values and their requirements are as follows:

* 0 (None)—Does not require other parameters.
* 3 (StandardDeviation)—Requires NumberOfStandardDeviations, Statistics, or DRA as true.
* 4 (Histogram Equalization)—Requires the source dataset to have histograms or additional DRA as true.
* 5 (MinMax)—Requires Statistics or DRA as true.
* 6 (PercentClip)—Requires MinPercent, MaxPercent, and DRA as true, or histograms from the source dataset.
* 9 (sigmoid)—Does not require other parameters. Optionally, set SigmoidStrengthLevel (1 to 6) to adjust the curvature of the Sigmoid curve used in color stretch.

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 3,
      "NumberOfStandardDeviations": 2.5,
      "Statistics": [
        [0, 255, 56.7, 54.8],
        [0, 255, 97.5, 94.5],
        [0, 255, 87.5, 87.3]
      ],
      "Min": 100,
      "Max": 255,
      "UseGamma": true,
      "Gamma": [1.25, 1.25, 1.25]
    },
    "outputPixelType": "U8",
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 5,
      "Statistics": [
        [50, 200, 56.7, 54.8],
        [50, 200, 97.5, 94.5],
        [50, 200, 87.5, 87.3]
      ],
      "Min": 100,
      "Max": 255,
      "UseGamma": false
    },
    "outputPixelType": "U8",
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 6,
      "MinPercent": 0.25,
      "MaxPercent": 0.25,
      "Gamma": [1.25, 1.25, 1.25],
      "DRA": true,
      "Min": 100,
      "Max": 255
    },
    "outputPixelType": "U8",
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 0
    },
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 4
    },
    "outputPixelType": "U8",
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "Stretch",
    "rasterFunctionArguments": {
      "StretchType": 9,
      "SigmoidStrengthLevel": 1
    },
    "outputPixelType": "U8",
    "variableName": "Raster"
  }
  ```

</Tab>

</Tabs>

#### SurfaceParamFunction

Introduced at 11.1, the `SurfaceParamFunction` function determines parameters of a raster surface such as aspect, slope, and several types of curvatures using geodesic methods. For more information, see [How Surface Parameters works in the Spatial Analyst tool](https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-analyst/how-surface-parameters-works.htm) help.

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "SurfaceParamFunction",
    "rasterFunctionArguments": {
      "SurfaceCalculation": <int> //Optional, 1=Mean curvature, 2=Profile curvature, 3=Tangential curvature, 4=Slope, 5=Aspect, 6=Plan curvature, 7=Contour geodesic torsion, 8=Gaussian curvature, 9=Casorati curvature. Default is 4. 
      "LocalSurface": <int>, //Optional, 1=Quadratic, 2=Biquadratic. Default is 1. 
      "AnalysisScaleWithUnits": <string >, //Optional. The output will be calculated over this distance from the target cell. Minimum value is the input raster cell size. Default is the input raster cell size and units. 	 
      "UseAdaptiveScale": <boolean>, //Optional. Default is false. 
      "ZUnit": <string> //Optional. Default is Meters. Options are: Centimeters, Decimal degrees, Decimeters, Feet, Inches, Kilometers, Meters, Miles, Millimeters, Nautical Miles, Points, Unknown and Yards. 
      "SlopeType": <int> //Optional, only applicable when SurfaceCalculation=4. 1=Degree, 2=Percent Rise	 
      "ProjectAzimuths": <boolean> // Optional, only applicable when SurfaceCalculation=5. Default is false. 
      "UseEquatorialAspect": <boolean> //Optional, only applicable when SurfaceCalculation=5. 
      “Raster”: <raster> 
    },
  }
  ```

</Tab>

<Tab>

This example demonstrates how to use `SurfaceParamFunction` to calculate aspect using a window whose size will adapt to the terrain described in the input raster.

  ```markdown
  { 
    "rasterFunction": "SurfaceParamFunction", 
    "rasterFunctionArguments": { 
      "SurfaceCalculation":5, 
      "AnalysisScaleWithUnits": "1 Meters", 
      "UseAdaptiveScale":true, 
      "Raster": "$$" 
    }, 
  }
  ```

</Tab>

</Tabs>

#### TasseledCap

The `TasseledCap` function analyzes and maps vegetation and urban development changes detected by various satellite sensor systems. It is known as the Tasseled Cap transformation due to the shape of the graphical distribution of data. This function takes no arguments except a raster. The input for this function is the source raster of an image service. There are no other parameters for this function because all the information is derived from the input's properties and key metadata (bands, data type, and sensor name). Only imagery from the Landsat MSS, Landsat TM, Landsat ETM+, IKONOS, QuickBird, WorldView-2, and RapidEye sensors are supported. Before applying this function, confirm that there are no functions in the function chain that would alter the pixel values, such as the `Stretch`, `Apparent Reflectance`, or `Pansharpening` functions. The only exception is when using Landsat ETM+: the `Apparent Reflectance` function must precede the `TasseledCapfunction`. For more information, see [Tasseled Cap function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/tasseled-cap-function.htm).

```markdown
{
  "rasterFunction": "TasseledCap",
  "rasterFunctionArguments": {
    "Raster": <raster>  //optional, default is the image service
  }
}
```

#### Threshold

The binary `Threshold` function produces the binary image. It uses the Otsu method and the input image is assumed to have a bimodal histogram. For more information, see [Binary Thresholding function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/binary-thresholding-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
{
  "rasterFunction": "Threshold",
  "rasterFunctionArguments": {
    "ThresholdType": <ThresholdType>,  //int 1=Otsu
    "Raster": <raster>  //optional, default is the image service 
  },
  "outputPixelType": "<outputPixelType>",  //optional
  "variableName": "Raster"
}
  ```

</Tab>

<Tab>

This example demonstrates the Otsu threshold.

  ```markdown
  {
    "rasterFunction": "Threshold",
    "rasterFunctionArguments": {
      "ThresholdType": 1,
      "Raster": "$$"
    }  
  }
  ```

</Tab>

</Tabs>

#### TransposeBits

The `TransposeBits` function performs a bit operation. It extracts bit values from the source data and assigns them to new bits in the output data. For more information, see [Transpose Bits function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/transpose-bits-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "TransposeBits",
    "rasterFunctionArguments": {
      "InputBitPositions": <InputBitPositions>,  //array of long, required
      "OutputBitPositions": <DirectionBandID>,  //array of long, required
      "ConstantFillCheck": <true | false>,  //bool, optional
      "ConstantFillValue": <ConstantFillValue>,  //int, required
      "Raster": <Raster>,  //optional, the input raster to be transposed, default is the service "$$"
      "FillRaster": <size>  //optional, the fill raster 
    },
    "outputPixelType": "<outputPixelType>"  //optional
  }
  ```
  If `ConstantFillCheck` is `false`, it is assumed there is an input `FillRaster` value. If an input `FillRaster` value is not provided, `ConstantFillCheck` reverts to `true` and checks for a `ConstantFillValue` value. Filling is used to initialize pixel values of the output raster.

  Landsat 8 has a quality assessment band. The following are example input and output bit positions to extract confidence levels by mapping them to 0-3:

  Landsat 8 Water: 
  ```markdown
  {"InputBitPositions":[4,5],"OutputBitPositions":[0,1]}
  ```
  Landsat 8 Cloud Shadow:
  ```markdown
  {"InputBitPositions":[6,7],"OutputBitPositions":[0,1]}
  ```
  Landsat 8 Vegetation:
  ```markdown
  {"InputBitPositions":[8,9],"OutputBitPositions":[0,1]}
  ```
  Landsat 8 Snow/Ice:
  ```markdown
  {"InputBitPositions":[10,11],"OutputBitPositions":[0,1]}
  ```
  Landsat 8 Cirrus:
  ```markdown
  {"InputBitPositions":[12,13],"OutputBitPositions":[0,1]}
  ```
  Landsat 8 Cloud:
  ```markdown
  {"InputBitPositions":[14,15],"OutputBitPositions":[0,1]}
  ```
  Landsat 8 Designated Fill:
  ```markdown
  {"InputBitPositions":[0],"OutputBitPositions":[0]}
  ```
  Landsat 8 Dropped Frame:
  ```markdown
  {"InputBitPositions":[1],"OutputBitPositions":[0]}
  ```
  Landsat 8 Terrain Occlusion:
  ```markdown
  {"InputBitPositions":[2],"OutputBitPositions":[0]}
  ```

</Tab>

<Tab>

This example demonstrates how to extract Landsat 8 Snow/Ice confidence levels.

  ```markdown
  {
    "rasterFunction": "TransposeBits",
    "rasterFunctionArguments": {
      "InputBitPositions": [10,11],
      "OutputBitPositions": [0,1],
      "ConstantFillValue": 0,
      "Raster": "$$",
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "U8",
  }
  ```

</Tab>

<Tab>

This example demonstrates how to extract Landsat 8 Cirrus confidence levels and map to different colors for visualization.

  ```markdown
  {	
    "rasterFunction": "Colormap",
    "rasterFunctionArguments": {
      "Colormap": [
        [0,255,0,0],
        [1,0,255,0],
        [2,0,0,255],
        [3,255,255,0]
      ],
      "Raster": {
          "rasterFunction": "TransposeBits",
        "rasterFunctionArguments": {
          "InputBitPositions": [12,13],
          "OutputBitPositions": [0,1],
          "ConstantFillValue": 0
        } 
      }
    }
  }
  ```

</Tab>

</Tabs>

#### Trend

Introduced at 10.8.1, the `Trend` function computes a forecasted multidimensional raster layer using the output trend raster from the [Generate Trend function](https://doc.arcgis.com/en/arcgis-online/analyze/generate-trend.htm) or [Generate Trend Raster geoprocessing tool](https://pro.arcgis.com/en/pro-app/latest/tool-reference/image-analyst/generate-trend-raster.htm).

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "Trend",
    "rasterFunctionArguments": {
      "DimensionDefinitionType": <int>,  // 0 means by value, 1 means by interval 
      "DimensionValues": <string>,  // optional. used when DimensionDefinitionType is 0. Multiple dimension values are separated by semicolon, e.g., "0;-2" or "1990-01-01T00:00:00;1990-01-02T00:00:00"
      "DimensionStart": <string>,  //optional. used when DimensionDefinitionType is 1. Defines the start of the dimension interval, e.g., "-10" or "1990-01-01T00:00:00"
      "DimensionEnd": <string>,  //optional. used when DimensionDefinitionType is 1. Defines the end of the dimension interval, e.g., "0" or "1991-01-01T00:00:00"
      "DimensionInterval": <int>,  //optional. used when DimensionDefinitionType is 1. Defines the step of each interval
      "DimensionUnit": <string>,  //optional. Used when DimensionDefinitionType is 1 and the dimension along which the trend is calculated is time related. Its value is one of the following: "YEARS", "MONTHS", "WEEKS", "DAYS", "HOURS".
      "Raster": <raster>  //optional, default is the image service
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

This example demonstrates how to predict the values at `DimensionValues` 0, -2, and -4.

  ```markdown
  {
    "rasterFunction": "Trend",
    "rasterFunctionArguments": {
      "DimensionDefinitionType":  0,  
      "DimensionValues": "0;-2;-4", 
      "Raster": "$$"
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to extract Landsat 8 Cirrus confidence levels and map to different colors for visualization.

  ```markdown
  {
    "rasterFunction": "Trend",
    "rasterFunctionArguments": {
      "DimensionDefinitionType": 1,  
      "DimensionStart": "1990-01-01T00:00:00", 
      "DimensionEnd": "1990-12-31T00:00:00", 
      "DimensionInterval": 1, 
      "DimensionUnit": "MONTHS", 
      "Raster": "$$"
    }
  }
  ```

</Tab>

</Tabs>

#### TrendAnalysis

Introduced at 10.8.1, the `TrendAnalysis` function estimates the trend for each pixel along a dimension for one or more variables in a multidimensional raster.

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Linear Trend</TabTitle>
  <TabTitle>Harmonic Trend</TabTitle>
  <TabTitle>Polynomial Trend</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "TrendAnalysis",
    "rasterFunctionArguments": {
      "DimensionName": <string>,  //the name of the dimension, along which the trend analysis is performed. e.g., "StdTime", "StdZ", etc. 
      "RegressionType": <int>,  //0=Linear (Default), 1=Harmonic, 2=Polynomial
      "Frequency": <int>,  //optional. Used when RegressionType = 1 (Harmonic). Default value of Frequency is 1, means that the seasonal pattern repeats once per year
      "Order": <int>,  //optional. Used when RegressionType = 2 (Polynomial). Default value of Order is 2, means 2nd order polynomial regression
      "IgnoreNoData": <bool>,  //optional. Default value is True, which means only cells that are not noData value will be used in fitting the trend curve
      "Raster": <raster>  //optional, default is the image service
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "TrendAnalysis",
    "rasterFunctionArguments": {
      "DimensionName": "StdTime",  
      "RegressionType": 0, 
      "Raster": "$$"
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to extract Landsat 8 Cirrus confidence levels and map to different colors for visualization.

  ```markdown
  {
    "rasterFunction": "TrendAnalysis",
    "rasterFunctionArguments": {
      "DimensionName": "StdTime",  
      "RegressionType": 1, 
      "Frequency": 2,
      "Raster": "$$"
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to extract Landsat 8 Cirrus confidence levels and map to different colors for visualization.

  ```markdown
  {
    "rasterFunction": "TrendAnalysis",
    "rasterFunctionArguments": {
      "DimensionName": "StdZ",  
      "RegressionType": 2, 
      "Order": 3,
      "Raster": "$$"
    }
  }
  ```

</Tab>

</Tabs>

#### TrendToRGB

Introduced at 10.8.1, the `TrendToRGB` function converts a trend raster to a three-band (red, green, and blue) raster. For more information, see [Trend to RGB function](https://doc.arcgis.com/en/arcgis-online/analyze/trend-to-rgb-function.htm).

<Note>

This function only works if the service provider is `arcobjects11` or `arcobjectsrasterrendering`.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "TrendToRGB",
    "rasterFunctionArguments": {
      "Raster": <Raster>,  //the input raster
      "ModelType": <ModelType>  //int, 0 = linear,1 = harmonic
    }
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "TrendToRGB",
    "rasterFunctionArguments": {
      "Raster": "$$",
      "ModelType": 0
    }
  }
  ```

</Tab>

</Tabs>

#### UnitConversion

The `UnitConversion` function performs unit conversions. For more information, see [Unit Conversion function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/unit-conversion-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "UnitConversion",
    "rasterFunctionArguments": {
      "FromUnit": <FromUnit>,  //units constant listed below (int)
      "ToUnit": <ToUnit>,  //units constant listed below (int)
      "Raster": <Raster>,  //the input raster, default is the service "$$"
    },
    "outputPixelType": "<outputPixelType>",  //optional
  }
  ```

  `FromUnit` and `ToUnit` take the following:

  * Speed units:
    * `100`: esriMetersPerSecond
    * `101`: esriKilometersPerHour
    * `102`: esriKnots
    * `103`: esriFeetPerSecond
    * `104`: esriMilesPerHour
  * Temperature units:
    * `200`: esriCelsius
    * `201`: esriFahrenheit
    * `202`: esriKelvin
  * Distance units
    * `1`: esriInches
    * `2`: esriPoints
    * `3`: esriFeet
    * `4`: esriYards
    * `5`: esriMiles
    * `6`: esriNauticalMiles
    * `7`: esriMillimeters
    * `8`: esriCentimeters
    * `9`: esriMeters
    * `10`: esriKilometers
    * `11`: esriDecimalDegrees
    * `12`: esriDecimeters

</Tab>

<Tab>

This example demonstrates how to convert pixel values from feet to meters.

  ```markdown
  {
    "rasterFunction": "UnitConversion",
    "rasterFunctionArguments": {
      "FromUnit": 3,
      "ToUnit": 9,
      "Raster": "$$"
    },
    "outputPixelType": "U8",
  }
  ```

</Tab>

</Tabs>

#### VectorField

The `VectorField` function composites and converts two single-band rasters (each raster represents U/V or Magnitude/Direction) into a two-band raster (each band represents U/V or Magnitude/Direction). The data combination type (U-V or Magnitude-Direction) can also be converted interchangeably with this function. For more information, see [Vector Field function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/vector-field-function.htm).

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "VectorField",
    "rasterFunctionArguments": {
      "Raster1": <raster>,  //raster item representing “U” or “Magnitude” 
      "Raster2": <raster>,  //raster item representing “V” or “Direction”
      "InputDataType": <string>,  //”Vector-UV” or “Vector-MagDir” per input used in “Raster1” and “Raster2”
      "AngleReferenceSystem": <int>,  //optional when “InputDataType” is “Vector-UV”. 0: Geographic; 1: Arithmetic
      "OutputDataType": <string>,  //”Vector-UV” or “Vector-MagDir”
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    }
  }
  ```

</Tab>

<Tab>

This example demonstrates how to perform a vector field data composite and a conversion from two single-band Magnitude and Direction rasters into one U-V two-band raster.

  ```markdown
  {
    "rasterFunction": "VectorField",
    "rasterFunctionArguments": {
      "Raster1": "$1",
      "Raster2": "$2",
      "AngleReferenceSystem": 0,
      "InputDataType": "Vector-MagDir",
      "OutputDataType": "Vector-UV"
    }
  }
  ```

</Tab>

</Tabs>

#### VectorFieldRenderer

The `VectorFieldRenderer` function symbolizes a U-V or Magnitude-Direction raster.

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "VectorFieldRenderer",
    "rasterFunctionArguments": {
      "MagnitudeBandID": <MagnitudeBandID>,
      "DirectionBandID": <DirectionBandID>,
      "IsUVComponents": <true | false>,  //bool
      "ReferenceSystem": <ReferenceSystem>,  //int 1=Arithmetic, 2= Angular
      "MassFlowAngleRepresentation": <representation>,  //int 0=from 1 =to
      "SymbolTileSize": <size>,
      "SymbolTileSizeUnits": <units>,
      "CalculationMethod": "<CalculationMethod>"  //"Vector Average", "Nearest neighbor", "Bilinear", "Cubic", "Minimum", "Maximum" |
      "SymbologyName": "<SymbologyName>",  //"Simple Scalar", "Single Arrow", "Wind Barb", "Beaufort Wind (Knots)", "Beaufort Wind (MetersPerSecond)", "Ocean Current (Knots)", "Ocean Current (MetersPerSecond)." |
      "MinimumMagnitude": <MinimumMagnitude>,
      "MaximumMagnitude": <MaximumMagnitude>,
      "MinimumSymbolSize": <MinimumSymbolSize>,
      "MaximumSymbolSize": <MaximumSymbolSize>
    },

    "variableName": "Raster"
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "VectorFieldRenderer",
    "rasterFunctionArguments": {
      "MagnitudeBandID": 0,
      "DirectionBandID": 1,
      "IsUVComponents": true,
      "ReferenceSystem": 1,
      "MassFlowAngleRepresentation": 0,
      "SymbolTileSize": 50,
      "SymbolTileSizeUnits": 100,
      "CalculationMethod": "Vector Average",
      "SymbologyName": "Single Arrow",
      "MinimumMagnitude": 1,
      "MaximumMagnitude": -1,
      "MinimumSymbolSize": 20,
      "MaximumSymbolSize": 80,
      "Raster": <Raster>  //optional
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Raster"
  }
  ```

</Tab>

</Tabs>

#### WeightedOverlay

The `WeightedOverlay` function overlays several rasters using a common measurement scale and weight each according to its importance. For more information, see [Weighted Overlay function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/weighted-overlay-function.htm).

<Note>

ArcGIS Server must be licensed as ArcGIS Server Advanced or ArcGIS Image Server to use this resource.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "WeightedOverlay",
    "rasterFunctionArguments": {
      "Rasters": [<raster1>,<raster2>,...],  //array of rasters.
      "Fields": ["<field1>","<field2>",...],  //[string, string, ...] 
      "Influences": [<influence1>,<influence2>,...],  //[double, double, ...]
      "Remaps": ["<remap1>","<remap2>",...],  //array of strings ["oldVal11 newVal11, oldVal12 newVal12, ...", "oldVal21 newVal21, oldVal22 newVal22, ...", ...]
      "EvalFrom": <evalfrom>,  //required, numeric value of evaluation scale from
      "EvalTo": <evalto>,  //required, numeric value of evaluation scale to
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Rasters"  //optional
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "WeightedOverlay",
    "rasterFunctionArguments": {
      "Rasters": ["$$","$$","$$"],
      "Fields": ["Value","Value","Value"],
      "Influences": [0.5,0.2,0.3],
      "Remaps": ["0 1, 1 1, 5 5", "1 1, 5 5, 10 NODATA", "0 1, 1 1, 9 9, NODATA -1"],
      "EvalFrom": -1,
      "EvalTo": 9
    }  
  }
  ```

</Tab>

</Tabs>

#### WeightedSum

The `WeightedSum` function overlays several rasters, multiplies each by their given weight, and adds them together. For more information, see [Weighted Sum function](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/weighted-sum-function.htm).

<Note>

ArcGIS Server must be licensed as ArcGIS Server Advanced or ArcGIS Image Server to use this resource.

</Note>

<Tabs>

<TabNav>
  <TabTitle>Syntax</TabTitle>
  <TabTitle>Example 1</TabTitle>
  <TabTitle>Example 2</TabTitle>
</TabNav>

<Tab>

  ```markdown
  {
    "rasterFunction": "WeightedSum",
    "rasterFunctionArguments": {
      "Rasters": [<raster1>,<raster2>,...],  //array of rasters.
      "Fields": ["<field1>","<field2>",...],  //[string, string, ...] 
      "Weights": [<weight1>,<weight2>,...],  //[double, double, ...]
      "MatchVariable": <true|false>,  //new at 10.9, boolean, optional, default is true
      "UnionDimension": <true|false>  //new at 10.9, boolean, optional, default is true
    },
    "outputPixelType": "<outputPixelType>",  //optional
    "variableName": "Rasters"  //optional
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "WeightedSum",
    "rasterFunctionArguments": {
      "Rasters": ["$$","$$","$$"],
      "Fields": ["Value","Value","Value"],
      "Weights": [0.25,0.25,0.5]
    }  
  }
  ```

</Tab>

<Tab>

  ```markdown
  {
    "rasterFunction": "WeightedSum",
    "rasterFunctionArguments": {
      "Rasters": ["$$","$$","$$"],
      "Fields": ["Value","Value","Value"],
      "Weights": [0.25,0.25,0.5],
      "MatchVariable": false,
      "UnionDimension": true
    }  
  }
  ```

</Tab>

</Tabs>